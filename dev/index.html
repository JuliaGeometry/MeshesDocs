<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · Meshes.jl</title><meta name="title" content="Home · Meshes.jl"/><meta property="og:title" content="Home · Meshes.jl"/><meta property="twitter:title" content="Home · Meshes.jl"/><meta name="description" content="Documentation for Meshes.jl."/><meta property="og:description" content="Documentation for Meshes.jl."/><meta property="twitter:description" content="Documentation for Meshes.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href><img src="assets/logo.svg" alt="Meshes.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href>Meshes.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#Quick-example"><span>Quick example</span></a></li></ul></li><li><span class="tocitem">Reference guide</span><ul><li><a class="tocitem" href="vectors/">Vectors</a></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Geometries</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="geometries/primitives/">Primitives</a></li><li><a class="tocitem" href="geometries/polytopes/">Polytopes</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Domains</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="domains/sets/">Sets</a></li><li><a class="tocitem" href="domains/meshes/">Meshes</a></li><li><a class="tocitem" href="domains/trajectories/">Trajectories</a></li></ul></li><li><a class="tocitem" href="predicates/">Predicates</a></li><li><input class="collapse-toggle" id="menuitem-2-5" type="checkbox"/><label class="tocitem" for="menuitem-2-5"><span class="docs-label">Algorithms</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="algorithms/sampling/">Sampling</a></li><li><a class="tocitem" href="algorithms/partitioning/">Partition</a></li><li><a class="tocitem" href="algorithms/discretization/">Discretization</a></li><li><a class="tocitem" href="algorithms/tesselation/">Tesselation</a></li><li><a class="tocitem" href="algorithms/refinement/">Refinement</a></li><li><a class="tocitem" href="algorithms/coarsening/">Coarsening</a></li><li><a class="tocitem" href="algorithms/simplification/">Simplification</a></li><li><a class="tocitem" href="algorithms/intersection/">Intersection</a></li><li><a class="tocitem" href="algorithms/clipping/">Clipping</a></li><li><a class="tocitem" href="algorithms/clamping/">Clamping</a></li><li><a class="tocitem" href="algorithms/merging/">Merging</a></li><li><a class="tocitem" href="algorithms/winding/">Winding</a></li><li><a class="tocitem" href="algorithms/sideof/">Sideof</a></li><li><a class="tocitem" href="algorithms/orientation/">Orientation</a></li><li><a class="tocitem" href="algorithms/neighborsearch/">Neighbor search</a></li><li><a class="tocitem" href="algorithms/boundingbox/">Bounding box</a></li><li><a class="tocitem" href="algorithms/hulls/">Hulls</a></li></ul></li><li><a class="tocitem" href="transforms/">Transforms</a></li><li><a class="tocitem" href="rand/">Random</a></li><li><a class="tocitem" href="visualization/">Visualization</a></li><li><a class="tocitem" href="io/">Input/Output</a></li><li><a class="tocitem" href="tolerances/">Tolerances</a></li></ul></li><li><span class="tocitem">Contributing</span><ul><li><a class="tocitem" href="contributing/guidelines/">Guidelines</a></li></ul></li><li><span class="tocitem">About</span><ul><li><a class="tocitem" href="about/license/">License</a></li></ul></li><li><a class="tocitem" href="links/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaGeometry/Meshes.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaGeometry/Meshes.jl/blob/master/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Meshes.jl"><a class="docs-heading-anchor" href="#Meshes.jl">Meshes.jl</a><a id="Meshes.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Meshes.jl" title="Permalink"></a></h1><p><em>Computational geometry and meshing algorithms in Julia.</em></p><p><a href="https://github.com/JuliaGeometry/Meshes.jl/actions"><img src="https://img.shields.io/github/actions/workflow/status/JuliaGeometry/Meshes.jl/CI.yml?branch=master&amp;style=flat-square" alt="Build Status"/></a> <a href="https://codecov.io/gh/JuliaGeometry/Meshes.jl"><img src="https://img.shields.io/codecov/c/github/JuliaGeometry/Meshes.jl?style=flat-square" alt="Coverage Status"/></a> <a href="https://JuliaGeometry.github.io/Meshes.jl/stable"><img src="https://img.shields.io/badge/docs-stable-blue?style=flat-square" alt="Stable Documentation"/></a> <a href="https://JuliaGeometry.github.io/Meshes.jl/dev"><img src="https://img.shields.io/badge/docs-latest-blue?style=flat-square" alt="Latest Documentation"/></a> <a href="https://github.com/JuliaGeometry/Meshes.jl/blob/master/LICENSE"><img src="https://img.shields.io/badge/license-MIT-blue?style=flat-square" alt="License File"/></a></p><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p><a href="https://github.com/JuliaGeometry/Meshes.jl">Meshes.jl</a> provides efficient implementations of concepts from computational geometry. It promotes rigorous mathematical definitions of spatial discretizations (a.k.a. meshes) that are adequate for describing general manifolds embedded in <span>$\mathbb{R}^3$</span>, including surfaces described with spherical coordinates, and geometries described with multiple coordinate reference systems.</p><p>Unlike other existing efforts in the Julia ecosystem, this project is being carefully designed to facilitate the use of <em>meshes across different scientific domains</em>. We follow a strict set of good software engineering practices, and are quite pedantic in our test suite to make sure that all our implementations are free of bugs in both single and double floating point precision. Additionally, we guarantee type stability.</p><p>The design of this project was motivated by various issues encountered with past attempts to represent geometry, which have been originally designed for visualization purposes (e.g. <a href="https://github.com/JuliaGeometry/GeometryTypes.jl">GeometryTypes.jl</a>, <a href="https://github.com/JuliaGeometry/GeometryBasics.jl">GeometryBasics.jl</a>) or specifically for finite element analysis (e.g. <a href="https://kristofferc.github.io/JuAFEM.jl/dev/manual/grid">JuAFEM.jl</a>, <a href="https://github.com/PetrKryslUCSD/MeshCore.jl">MeshCore.jl</a>). We hope to provide a smoother experience with mesh representations that are adequate for finite finite element analysis, advanced geospatial modeling <em>and</em> visualization, not just one domain.</p><p>The <a href="https://juliaearth.github.io/geospatial-data-science-with-julia">Geospatial Data Science with Julia</a> book is a great resource to learn more about <a href="https://github.com/JuliaGeometry/Meshes.jl">Meshes.jl</a> and geospatial data (i.e. tables over meshes):</p><p align="center">
  <a href="https://juliaearth.github.io/geospatial-data-science-with-julia">
    <img src="https://juliaearth.github.io/geospatial-data-science-with-julia/images/cover.svg" width="200px" hspace="20">
  </a>
</p><p>If you have questions or would like to brainstorm ideas, don&#39;t hesitate to start a thread in our <a href="https://julialang.zulipchat.com/#narrow/stream/275558-meshes.2Ejl">zulip channel</a>.</p><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><p>Get the latest stable release with Julia&#39;s package manager:</p><pre><code class="nohighlight hljs">] add Meshes</code></pre><h2 id="Quick-example"><a class="docs-heading-anchor" href="#Quick-example">Quick example</a><a id="Quick-example-1"></a><a class="docs-heading-anchor-permalink" href="#Quick-example" title="Permalink"></a></h2><p>Although we didn&#39;t have time to document the functionality of the package properly, we still would like to illustrate some important features. For more information on available functionality, please consult the <a href="vectors/">Reference guide</a> and the <a href="https://github.com/JuliaGeometry/Meshes.jl/tree/master/test">suite of tests</a> in the package.</p><p>In all examples we assume the following packages are loaded:</p><pre><code class="language-julia hljs">using Meshes
import CairoMakie as Mke</code></pre><h3 id="Points-and-vectors"><a class="docs-heading-anchor" href="#Points-and-vectors">Points and vectors</a><a id="Points-and-vectors-1"></a><a class="docs-heading-anchor-permalink" href="#Points-and-vectors" title="Permalink"></a></h3><p>A <a href="geometries/primitives/#Point"><code>Point</code></a> is defined by its coordinates in a coordinate reference system from <a href="https://github.com/JuliaEarth/CoordRefSystems.jl">CoordRefSystems.jl</a>. By default, a <code>Cartesian</code> coordinates with <code>NoDatum</code> are used.</p><p><code>Integer</code> coordinates are converted to <code>Float64</code> to fulfill the requirements of most geometric processing algorithms, which would be undefined in a discrete scale:</p><pre><code class="language-julia hljs">Point(0.0, 1.0) # double precision as expected</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Point with Cartesian{NoDatum} coordinates
├─ x: 0.0 m
└─ y: 1.0 m</code></pre><pre><code class="language-julia hljs">Point(0f0, 1f0) # single precision as expected</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Point with Cartesian{NoDatum} coordinates
├─ x: 0.0f0 m
└─ y: 1.0f0 m</code></pre><pre><code class="language-julia hljs">Point(0, 0) # Integer is converted to Float64 by design</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Point with Cartesian{NoDatum} coordinates
├─ x: 0.0 m
└─ y: 0.0 m</code></pre><pre><code class="language-julia hljs">Point(1.0, 2.0, 3.0) # double precision as expected</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Point with Cartesian{NoDatum} coordinates
├─ x: 1.0 m
├─ y: 2.0 m
└─ z: 3.0 m</code></pre><pre><code class="language-julia hljs">Point(1f0, 2f0, 3f0) # single precision as expected</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Point with Cartesian{NoDatum} coordinates
├─ x: 1.0f0 m
├─ y: 2.0f0 m
└─ z: 3.0f0 m</code></pre><pre><code class="language-julia hljs">Point(1, 2, 3) # Integer is converted to Float64 by design</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Point with Cartesian{NoDatum} coordinates
├─ x: 1.0 m
├─ y: 2.0 m
└─ z: 3.0 m</code></pre><p>Points can be subtracted to produce a vector:</p><pre><code class="language-julia hljs">A = Point(1.0, 1.0)
B = Point(3.0, 3.0)
B - A</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Vec(2.0 m, 2.0 m)</code></pre><p>They can&#39;t be added, but the vectors from the origin to the points can:</p><pre><code class="language-julia hljs">to(A) + to(B)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Vec(4.0 m, 4.0 m)</code></pre><p>We can add a point to a vector though, and get a new point:</p><pre><code class="language-julia hljs">A + Vec(1, 1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Point with Cartesian{NoDatum} coordinates
├─ x: 2.0 m
└─ y: 2.0 m</code></pre><p>Every point and vector has well-defined coordinates:</p><pre><code class="language-julia hljs">coords(A)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Cartesian{NoDatum} coordinates
├─ x: 1.0 m
└─ y: 1.0 m</code></pre><h3 id="Primitives"><a class="docs-heading-anchor" href="#Primitives">Primitives</a><a id="Primitives-1"></a><a class="docs-heading-anchor-permalink" href="#Primitives" title="Permalink"></a></h3><p>Primitive geometries such as <a href="geometries/primitives/#Box"><code>Box</code></a>, <a href="algorithms/partitioning/#Ball"><code>Ball</code></a>, <a href="geometries/primitives/#Meshes.Sphere"><code>Sphere</code></a>, <a href="geometries/primitives/#Meshes.Cylinder"><code>Cylinder</code></a> are those geometries that can be efficiently represented in a computer without discretization. We can construct such geometries using clean syntax:</p><pre><code class="language-julia hljs">b = Box((0.0, 0.0, 0.0), (1.0, 1.0, 1.0))

viz(b)</code></pre><img src="index-82213b00.png" alt="Example block output"/><pre><code class="language-julia hljs">s = Sphere((0.0, 0.0, 0.0), 1.0)

viz(s)</code></pre><img src="index-8c17abe7.png" alt="Example block output"/><p>The parameters of these primitive geometries can be queried easily:</p><pre><code class="language-julia hljs">extrema(b)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(Point(x: 0.0 m, y: 0.0 m, z: 0.0 m), Point(x: 1.0 m, y: 1.0 m, z: 1.0 m))</code></pre><pre><code class="language-julia hljs">centroid(s), radius(s)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(Point(x: 0.0 m, y: 0.0 m, z: 0.0 m), 1.0 m)</code></pre><p>As well as their measure (e.g. area, volume) and other geometric properties:</p><pre><code class="language-julia hljs">measure(b)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1.0 m^3</code></pre><p>We can sample random points on primitives using different methods:</p><pre><code class="language-julia hljs">vs = sample(s, RegularSampling(10)) # 10 points over the sphere</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Base.Iterators.Flatten{Base.Generator{Tuple{Base.Generator{Base.Iterators.ProductIterator{Tuple{StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}}, Meshes.var&quot;#444#448&quot;{Sphere{𝔼{3}, CoordRefSystems.Cartesian3D{CoordRefSystems.NoDatum, Unitful.Quantity{Float64, 𝐋, Unitful.FreeUnits{(m,), 𝐋, nothing}}}, Unitful.Quantity{Float64, 𝐋, Unitful.FreeUnits{(m,), 𝐋, nothing}}}}}, Base.Generator{Tuple{Point{𝔼{3}, CoordRefSystems.Cartesian3D{CoordRefSystems.NoDatum, Unitful.Quantity{Float64, 𝐋, Unitful.FreeUnits{(m,), 𝐋, nothing}}}}, Point{𝔼{3}, CoordRefSystems.Cartesian3D{CoordRefSystems.NoDatum, Unitful.Quantity{Float64, 𝐋, Unitful.FreeUnits{(m,), 𝐋, nothing}}}}}, typeof(identity)}}, typeof(identity)}}(Base.Generator{Tuple{Base.Generator{Base.Iterators.ProductIterator{Tuple{StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}}, Meshes.var&quot;#444#448&quot;{Sphere{𝔼{3}, CoordRefSystems.Cartesian3D{CoordRefSystems.NoDatum, Unitful.Quantity{Float64, 𝐋, Unitful.FreeUnits{(m,), 𝐋, nothing}}}, Unitful.Quantity{Float64, 𝐋, Unitful.FreeUnits{(m,), 𝐋, nothing}}}}}, Base.Generator{Tuple{Point{𝔼{3}, CoordRefSystems.Cartesian3D{CoordRefSystems.NoDatum, Unitful.Quantity{Float64, 𝐋, Unitful.FreeUnits{(m,), 𝐋, nothing}}}}, Point{𝔼{3}, CoordRefSystems.Cartesian3D{CoordRefSystems.NoDatum, Unitful.Quantity{Float64, 𝐋, Unitful.FreeUnits{(m,), 𝐋, nothing}}}}}, typeof(identity)}}, typeof(identity)}(identity, (Base.Generator{Base.Iterators.ProductIterator{Tuple{StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}}, Meshes.var&quot;#444#448&quot;{Sphere{𝔼{3}, CoordRefSystems.Cartesian3D{CoordRefSystems.NoDatum, Unitful.Quantity{Float64, 𝐋, Unitful.FreeUnits{(m,), 𝐋, nothing}}}, Unitful.Quantity{Float64, 𝐋, Unitful.FreeUnits{(m,), 𝐋, nothing}}}}}(Meshes.var&quot;#444#448&quot;{Sphere{𝔼{3}, CoordRefSystems.Cartesian3D{CoordRefSystems.NoDatum, Unitful.Quantity{Float64, 𝐋, Unitful.FreeUnits{(m,), 𝐋, nothing}}}, Unitful.Quantity{Float64, 𝐋, Unitful.FreeUnits{(m,), 𝐋, nothing}}}}(Sphere(center: (x: 0.0 m, y: 0.0 m, z: 0.0 m), radius: 1.0 m)), Base.Iterators.ProductIterator{Tuple{StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}}((0.09090909090909091:0.09090909090909091:0.9090909090909091, 0.0:0.1:0.9))), Base.Generator{Tuple{Point{𝔼{3}, CoordRefSystems.Cartesian3D{CoordRefSystems.NoDatum, Unitful.Quantity{Float64, 𝐋, Unitful.FreeUnits{(m,), 𝐋, nothing}}}}, Point{𝔼{3}, CoordRefSystems.Cartesian3D{CoordRefSystems.NoDatum, Unitful.Quantity{Float64, 𝐋, Unitful.FreeUnits{(m,), 𝐋, nothing}}}}}, typeof(identity)}(identity, (Point(x: 0.0 m, y: 0.0 m, z: 1.0 m), Point(x: 0.0 m, y: 0.0 m, z: -1.0 m))))))</code></pre><p>And collect the generator with:</p><pre><code class="language-julia hljs">viz(collect(vs))</code></pre><img src="index-54fd05ed.png" alt="Example block output"/><h3 id="Polytopes"><a class="docs-heading-anchor" href="#Polytopes">Polytopes</a><a id="Polytopes-1"></a><a class="docs-heading-anchor-permalink" href="#Polytopes" title="Permalink"></a></h3><p>Polytopes are geometries with &quot;flat&quot; sides. They generalize polygons and polyhedra. Most commonly used polytopes are already defined in the project, including <a href="geometries/polytopes/#Segment"><code>Segment</code></a>, <a href="geometries/polytopes/#Ngon"><code>Ngon</code></a> (e.g. Triangle, Quadrangle), <a href="geometries/polytopes/#Tetrahedron"><code>Tetrahedron</code></a>, <a href="geometries/polytopes/#Pyramid"><code>Pyramid</code></a> and <a href="geometries/polytopes/#Hexahedron"><code>Hexahedron</code></a>.</p><pre><code class="language-julia hljs">t = Triangle((0.0, 0.0), (1.0, 0.0), (0.0, 1.0))

viz(t)</code></pre><img src="index-2c1d051d.png" alt="Example block output"/><p>Some of these geometries have additional functionality like the measure (or area):</p><pre><code class="language-julia hljs">measure(t)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.5 m^2</code></pre><pre><code class="language-julia hljs">measure(t) == area(t)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>Or the ability to know whether or not a point is inside:</p><pre><code class="language-julia hljs">p = Point(0.5, 0.0)

p ∈ t</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>For line segments, for example, we have robust intersection algorithms:</p><pre><code class="language-julia hljs">s1 = Segment((0.0, 0.0), (1.0, 0.0))
s2 = Segment((0.5, 0.0), (2.0, 0.0))

s1 ∩ s2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Segment
├─ Point(x: 0.5 m, y: 0.0 m)
└─ Point(x: 1.0 m, y: 0.0 m)</code></pre><p>Polytopes are widely used in GIS software under names such as &quot;LineString&quot; and &quot;Polygon&quot;. We provide robust implementations of these concepts, which are formally known as polygonal <a href="geometries/polytopes/#Meshes.Chain"><code>Chain</code></a> and <a href="geometries/polytopes/#PolyArea"><code>PolyArea</code></a>.</p><p>We can compute the orientation of a chain as clockwise or counter-clockwise, can open and close the chain, create bridges between the various inner rings with the outer ring, and other useful functionality:</p><pre><code class="language-julia hljs">p = PolyArea((0,0), (2,0), (2,2), (1,3), (0,2))

viz(p)</code></pre><img src="index-f0918634.png" alt="Example block output"/><p>The orientation of the above polygonal area is counter-clockwise (CCW):</p><pre><code class="language-julia hljs">orientation(p)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">CCW::OrientationType = 1</code></pre><p>We can get the outer ring, and reverse it:</p><pre><code class="language-julia hljs">r = rings(p) |&gt; first

reverse(r)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Ring
├─ Point(x: 0.0 m, y: 0.0 m)
├─ Point(x: 0.0 m, y: 2.0 m)
├─ Point(x: 1.0 m, y: 3.0 m)
├─ Point(x: 2.0 m, y: 2.0 m)
└─ Point(x: 2.0 m, y: 0.0 m)</code></pre><p>A ring has circular vertices:</p><pre><code class="language-julia hljs">v = vertices(r)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element CircularVector(::Vector{Point{𝔼{2}, CoordRefSystems.Cartesian2D{CoordRefSystems.NoDatum, Unitful.Quantity{Float64, 𝐋, Unitful.FreeUnits{(m,), 𝐋, nothing}}}}}):
 Point(x: 0.0 m, y: 0.0 m)
 Point(x: 2.0 m, y: 0.0 m)
 Point(x: 2.0 m, y: 2.0 m)
 Point(x: 1.0 m, y: 3.0 m)
 Point(x: 0.0 m, y: 2.0 m)</code></pre><p>This means that we can index the vertices with indices that go beyond the range <code>1:nvertices(r)</code>. This is very useful for writing algorithms:</p><pre><code class="language-julia hljs">v[1:10]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10-element CircularVector(::Vector{Point{𝔼{2}, CoordRefSystems.Cartesian2D{CoordRefSystems.NoDatum, Unitful.Quantity{Float64, 𝐋, Unitful.FreeUnits{(m,), 𝐋, nothing}}}}}):
 Point(x: 0.0 m, y: 0.0 m)
 Point(x: 2.0 m, y: 0.0 m)
 Point(x: 2.0 m, y: 2.0 m)
 Point(x: 1.0 m, y: 3.0 m)
 Point(x: 0.0 m, y: 2.0 m)
 Point(x: 0.0 m, y: 0.0 m)
 Point(x: 2.0 m, y: 0.0 m)
 Point(x: 2.0 m, y: 2.0 m)
 Point(x: 1.0 m, y: 3.0 m)
 Point(x: 0.0 m, y: 2.0 m)</code></pre><p>We can also compute angles of any given chain, no matter if it is open or closed:</p><pre><code class="language-julia hljs">angles(r)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element Vector{Unitful.Quantity{Float64, NoDims, Unitful.FreeUnits{(rad,), NoDims, nothing}}}:
 -1.5707963267948966 rad
 -1.5707963267948966 rad
  -2.356194490192345 rad
 -1.5707963267948966 rad
  -2.356194490192345 rad</code></pre><p>The sign of these angles is a function of the orientation:</p><pre><code class="language-julia hljs">angles(reverse(r))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element Vector{Unitful.Quantity{Float64, NoDims, Unitful.FreeUnits{(rad,), NoDims, nothing}}}:
 1.5707963267948966 rad
  2.356194490192345 rad
 1.5707963267948966 rad
  2.356194490192345 rad
 1.5707963267948966 rad</code></pre><p>In case of rings (i.e. closed chains), we can compute inner angles as well:</p><pre><code class="language-julia hljs">innerangles(r)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element Vector{Unitful.Quantity{Float64, NoDims, Unitful.FreeUnits{(rad,), NoDims, nothing}}}:
 1.5707963267948966 rad
 1.5707963267948966 rad
  2.356194490192345 rad
 1.5707963267948966 rad
  2.356194490192345 rad</code></pre><p>And there is a lot more functionality available like for instance determining whether or not a polygonal area or chain is simple:</p><pre><code class="language-julia hljs">issimple(p)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><h3 id="Meshes"><a class="docs-heading-anchor" href="#Meshes">Meshes</a><a id="Meshes-1"></a><a class="docs-heading-anchor-permalink" href="#Meshes" title="Permalink"></a></h3><p>Efficient (lazy) mesh representations are provided, including <a href="domains/meshes/#Meshes.CartesianGrid"><code>CartesianGrid</code></a> and <a href="domains/meshes/#Meshes.SimpleMesh"><code>SimpleMesh</code></a>, which are specific types of <a href="#Meshes.Domain"><code>Domain</code></a>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Meshes.Domain" href="#Meshes.Domain"><code>Meshes.Domain</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Domain{M,CRS}</code></pre><p>A domain is an indexable collection of geometries (e.g. mesh) in a given manifold <code>M</code> with point coordinates specified in a coordinate reference system <code>CRS</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Meshes.jl/blob/8c11cbe9179ff12890b99d3aea22e973fa1808fc/src/domains.jl#L5-L11">source</a></section></article><pre><code class="language-julia hljs">grid = CartesianGrid(100, 100)

viz(grid, showsegments = true)</code></pre><img src="index-3715c8ab.png" alt="Example block output"/><p>No memory is allocated:</p><pre><code class="language-julia hljs">@allocated CartesianGrid(10000, 10000, 10000)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0</code></pre><p>but we can still loop over the elements, which are quadrangles in 2D:</p><pre><code class="language-julia hljs">collect(grid)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10000-element Vector{Quadrangle{𝔼{2}, CoordRefSystems.Cartesian2D{CoordRefSystems.NoDatum, Unitful.Quantity{Float64, 𝐋, Unitful.FreeUnits{(m,), 𝐋, nothing}}}}}:
 Quadrangle((x: 0.0 m, y: 0.0 m), ..., (x: 0.0 m, y: 1.0 m))
 Quadrangle((x: 1.0 m, y: 0.0 m), ..., (x: 1.0 m, y: 1.0 m))
 Quadrangle((x: 2.0 m, y: 0.0 m), ..., (x: 2.0 m, y: 1.0 m))
 Quadrangle((x: 3.0 m, y: 0.0 m), ..., (x: 3.0 m, y: 1.0 m))
 Quadrangle((x: 4.0 m, y: 0.0 m), ..., (x: 4.0 m, y: 1.0 m))
 Quadrangle((x: 5.0 m, y: 0.0 m), ..., (x: 5.0 m, y: 1.0 m))
 Quadrangle((x: 6.0 m, y: 0.0 m), ..., (x: 6.0 m, y: 1.0 m))
 Quadrangle((x: 7.0 m, y: 0.0 m), ..., (x: 7.0 m, y: 1.0 m))
 Quadrangle((x: 8.0 m, y: 0.0 m), ..., (x: 8.0 m, y: 1.0 m))
 Quadrangle((x: 9.0 m, y: 0.0 m), ..., (x: 9.0 m, y: 1.0 m))
 ⋮
 Quadrangle((x: 91.0 m, y: 99.0 m), ..., (x: 91.0 m, y: 100.0 m))
 Quadrangle((x: 92.0 m, y: 99.0 m), ..., (x: 92.0 m, y: 100.0 m))
 Quadrangle((x: 93.0 m, y: 99.0 m), ..., (x: 93.0 m, y: 100.0 m))
 Quadrangle((x: 94.0 m, y: 99.0 m), ..., (x: 94.0 m, y: 100.0 m))
 Quadrangle((x: 95.0 m, y: 99.0 m), ..., (x: 95.0 m, y: 100.0 m))
 Quadrangle((x: 96.0 m, y: 99.0 m), ..., (x: 96.0 m, y: 100.0 m))
 Quadrangle((x: 97.0 m, y: 99.0 m), ..., (x: 97.0 m, y: 100.0 m))
 Quadrangle((x: 98.0 m, y: 99.0 m), ..., (x: 98.0 m, y: 100.0 m))
 Quadrangle((x: 99.0 m, y: 99.0 m), ..., (x: 99.0 m, y: 100.0 m))</code></pre><p>We can construct a general unstructured mesh with a global vector of points and a collection of <a href="domains/meshes/#Meshes.Connectivity"><code>Connectivity</code></a> that store the indices to the global vector of points:</p><pre><code class="language-julia hljs">points = [(0,0), (1,0), (0,1), (1,1), (0.25,0.5), (0.75,0.5)]
tris  = connect.([(1,5,3), (4,6,2)], Triangle)
quads = connect.([(1,2,6,5), (4,3,5,6)], Quadrangle)
mesh = SimpleMesh(points, [tris; quads])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4 SimpleMesh
  6 vertices
  ├─ Point(x: 0.0 m, y: 0.0 m)
  ├─ Point(x: 1.0 m, y: 0.0 m)
  ├─ Point(x: 0.0 m, y: 1.0 m)
  ├─ Point(x: 1.0 m, y: 1.0 m)
  ├─ Point(x: 0.25 m, y: 0.5 m)
  └─ Point(x: 0.75 m, y: 0.5 m)
  4 elements
  ├─ Triangle(1, 5, 3)
  ├─ Triangle(4, 6, 2)
  ├─ Quadrangle(1, 2, 6, 5)
  └─ Quadrangle(4, 3, 5, 6)</code></pre><pre><code class="language-julia hljs">viz(mesh, showsegments = true)</code></pre><img src="index-c10c8cc5.png" alt="Example block output"/><p>The actual geometries of the elements are materialized in a lazy fashion like with the Cartesian grid:</p><pre><code class="language-julia hljs">collect(mesh)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Ngon{N, 𝔼{2}, CoordRefSystems.Cartesian2D{CoordRefSystems.NoDatum, Unitful.Quantity{Float64, 𝐋, Unitful.FreeUnits{(m,), 𝐋, nothing}}}} where N}:
 Triangle((x: 0.0 m, y: 0.0 m), (x: 0.25 m, y: 0.5 m), (x: 0.0 m, y: 1.0 m))
 Triangle((x: 1.0 m, y: 1.0 m), (x: 0.75 m, y: 0.5 m), (x: 1.0 m, y: 0.0 m))
 Quadrangle((x: 0.0 m, y: 0.0 m), ..., (x: 0.25 m, y: 0.5 m))
 Quadrangle((x: 1.0 m, y: 1.0 m), ..., (x: 0.75 m, y: 0.5 m))</code></pre></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="vectors/">Vectors »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Thursday 12 September 2024 13:45">Thursday 12 September 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

var documenterSearchIndex = {"docs":
[{"location":"geometries/polytopes/#Polytopes","page":"Polytopes","title":"Polytopes","text":"","category":"section"},{"location":"geometries/polytopes/","page":"Polytopes","title":"Polytopes","text":"using Meshes # hide\nimport CairoMakie as Mke # hide","category":"page"},{"location":"geometries/polytopes/#Abstract","page":"Polytopes","title":"Abstract","text":"","category":"section"},{"location":"geometries/polytopes/","page":"Polytopes","title":"Polytopes","text":"Polytope\nChain\nPolygon\nPolyhedron","category":"page"},{"location":"geometries/polytopes/#Meshes.Polytope","page":"Polytopes","title":"Meshes.Polytope","text":"Polytope{K,M,CRS}\n\nWe say that a geometry is a K-polytope when it is a collection of \"flat\" sides that constitute a K-dimensional subspace. They are called chain, polygon and polyhedron respectively for 1D (K=1), 2D (K=2) and 3D (K=3) subspaces. The parameter K is also known as the rank or parametric dimension  of the polytope (https://en.wikipedia.org/wiki/Abstract_polytope).\n\nThe term polytope expresses a particular combinatorial structure. A polyhedron, for example, can be decomposed into faces. Each face can then be decomposed into edges, and edges into vertices. Some conventions act as a mapping between vertices and higher dimensional features (edges, faces, cells...), removing the need to store all features.\n\nAdditionally, the following property must hold in order for a geometry to be considered a polytope: the boundary of a (K+1)-polytope is a collection of K-polytopes, which may have (K-1)-polytopes in common. See https://en.wikipedia.org/wiki/Polytope.\n\nNotes\n\nType aliases are Chain, Polygon, Polyhedron.\n\n\n\n\n\n","category":"type"},{"location":"geometries/polytopes/#Meshes.Chain","page":"Polytopes","title":"Meshes.Chain","text":"Chain{M,CRS}\n\nA chain is a 1-polytope, i.e. a polytope with parametric dimension 1. See https://en.wikipedia.org/wiki/Polygonal_chain.\n\nSee also Segment, Rope, Ring.\n\n\n\n\n\n","category":"type"},{"location":"geometries/polytopes/#Meshes.Polygon","page":"Polytopes","title":"Meshes.Polygon","text":"Polygon{M,CRS}\n\nA polygon is a 2-polytope, i.e. a polytope with parametric dimension 2.\n\nSee also Ngon and PolyArea.\n\n\n\n\n\n","category":"type"},{"location":"geometries/polytopes/#Meshes.Polyhedron","page":"Polytopes","title":"Meshes.Polyhedron","text":"Polyhedron{M,CRS}\n\nA polyhedron is a 3-polytope, i.e. a polytope with parametric dimension 3.\n\nSee also Tetrahedron, Hexahedron and Pyramid.\n\n\n\n\n\n","category":"type"},{"location":"geometries/polytopes/#Concrete","page":"Polytopes","title":"Concrete","text":"","category":"section"},{"location":"geometries/polytopes/#Segment","page":"Polytopes","title":"Segment","text":"","category":"section"},{"location":"geometries/polytopes/","page":"Polytopes","title":"Polytopes","text":"Segment","category":"page"},{"location":"geometries/polytopes/#Meshes.Segment","page":"Polytopes","title":"Meshes.Segment","text":"Segment(p1, p2)\n\nAn oriented line segment with end points p1, p2. The segment can be called as s(t) with t between 0 and 1 to interpolate linearly between its endpoints.\n\nSee also Rope, Ring, Line.\n\n\n\n\n\n","category":"type"},{"location":"geometries/polytopes/","page":"Polytopes","title":"Polytopes","text":"Segment((0., 0.), (1.,1.)) |> viz","category":"page"},{"location":"geometries/polytopes/#Rope","page":"Polytopes","title":"Rope","text":"","category":"section"},{"location":"geometries/polytopes/","page":"Polytopes","title":"Polytopes","text":"Rope","category":"page"},{"location":"geometries/polytopes/#Meshes.Rope","page":"Polytopes","title":"Meshes.Rope","text":"Rope(p1, p2, ..., pn)\n\nAn open polygonal chain from a sequence of points p1, p2, ..., pn.\n\nSee also Chain and Ring.\n\n\n\n\n\n","category":"type"},{"location":"geometries/polytopes/","page":"Polytopes","title":"Polytopes","text":"Rope((0.,0.), (1.,0.5), (1.,1.), (2.,0.)) |> viz","category":"page"},{"location":"geometries/polytopes/#Ring","page":"Polytopes","title":"Ring","text":"","category":"section"},{"location":"geometries/polytopes/","page":"Polytopes","title":"Polytopes","text":"Ring","category":"page"},{"location":"geometries/polytopes/#Meshes.Ring","page":"Polytopes","title":"Meshes.Ring","text":"Ring(p1, p2, ..., pn)\n\nA closed polygonal chain from a sequence of points p1, p2, ..., pn.\n\nSee also Chain and Rope.\n\n\n\n\n\n","category":"type"},{"location":"geometries/polytopes/","page":"Polytopes","title":"Polytopes","text":"Ring((0.,0.), (1.,0.5), (1.,1.), (2.,0.)) |> viz","category":"page"},{"location":"geometries/polytopes/#Ngon","page":"Polytopes","title":"Ngon","text":"","category":"section"},{"location":"geometries/polytopes/","page":"Polytopes","title":"Polytopes","text":"Ngon","category":"page"},{"location":"geometries/polytopes/#Meshes.Ngon","page":"Polytopes","title":"Meshes.Ngon","text":"Ngon(p₁, p₂, ..., pₙ)\n\nA N-gon is a polygon with N ≥ 3 vertices p₁, p₂, ..., pₙ oriented counter-clockwise (CCW). In this case the number of vertices is fixed and known at compile time. Examples of N-gon are Triangle (N=3), Quadrangle (N=4), Pentagon (N=5), etc.\n\nNotes\n\nAlthough the number of vertices N is known at compile time, we use abstract vectors to store the list of vertices. This design allows constructing N-gon from views of global vectors without expensive memory allocations.\nType aliases are Triangle, Quadrangle, Pentagon, Hexagon, Heptagon, Octagon, Nonagon, Decagon.\n\n\n\n\n\n","category":"type"},{"location":"geometries/polytopes/","page":"Polytopes","title":"Polytopes","text":"Triangle((0.,0.), (1.,0.), (0.,1.)) |> viz","category":"page"},{"location":"geometries/polytopes/#PolyArea","page":"Polytopes","title":"PolyArea","text":"","category":"section"},{"location":"geometries/polytopes/","page":"Polytopes","title":"Polytopes","text":"PolyArea","category":"page"},{"location":"geometries/polytopes/#Meshes.PolyArea","page":"Polytopes","title":"Meshes.PolyArea","text":"PolyArea(outer)\nPolyArea([outer, inner₁, inner₂, ..., innerₖ])\n\nA polygonal area with outer ring, and optional inner rings inner₁, inner₂, ..., innerₖ.\n\nRings can be a vector of Point or a vector of tuples with coordinates for convenience, in which case the first point should not be repeated at the end of the vector.\n\n\n\n\n\n","category":"type"},{"location":"geometries/polytopes/","page":"Polytopes","title":"Polytopes","text":"outer = [(0, 0), (1, 0), (1, 1), (0, 1)]\nhole1 = [(0.2, 0.2), (0.2, 0.4), (0.4, 0.4), (0.4, 0.2)]\nhole2 = [(0.6, 0.2), (0.6, 0.4), (0.8, 0.4), (0.8, 0.2)]\npoly  = PolyArea([outer, hole1, hole2]) |> viz","category":"page"},{"location":"geometries/polytopes/#Tetrahedron","page":"Polytopes","title":"Tetrahedron","text":"","category":"section"},{"location":"geometries/polytopes/","page":"Polytopes","title":"Polytopes","text":"Tetrahedron","category":"page"},{"location":"geometries/polytopes/#Meshes.Tetrahedron","page":"Polytopes","title":"Meshes.Tetrahedron","text":"Tetrahedron(p1, p2, p3, p4)\n\nA tetrahedron with points p1, p2, p3, p4.\n\n\n\n\n\n","category":"type"},{"location":"geometries/polytopes/","page":"Polytopes","title":"Polytopes","text":"Tetrahedron((0,0,0),(1,0,0),(0,1,0),(0,0,1)) |> viz","category":"page"},{"location":"geometries/polytopes/#Hexahedron","page":"Polytopes","title":"Hexahedron","text":"","category":"section"},{"location":"geometries/polytopes/","page":"Polytopes","title":"Polytopes","text":"Hexahedron","category":"page"},{"location":"geometries/polytopes/#Meshes.Hexahedron","page":"Polytopes","title":"Meshes.Hexahedron","text":"Hexahedron(p1, p2, ..., p8)\n\nA hexahedron with points p1, p2, ..., p8.\n\n\n\n\n\n","category":"type"},{"location":"geometries/polytopes/","page":"Polytopes","title":"Polytopes","text":"Hexahedron((0,0,0),(1,0,0),(1,1,0),(0,1,0),(0,0,1),(1,0,1),(1,1,1),(0,1,1)) |> viz","category":"page"},{"location":"geometries/polytopes/#Pyramid","page":"Polytopes","title":"Pyramid","text":"","category":"section"},{"location":"geometries/polytopes/","page":"Polytopes","title":"Polytopes","text":"Pyramid","category":"page"},{"location":"geometries/polytopes/#Meshes.Pyramid","page":"Polytopes","title":"Meshes.Pyramid","text":"Pyramid(p1, p2, p3, p4, p5)\n\nA pyramid with points p1, p2, p3, p4, p5.\n\n\n\n\n\n","category":"type"},{"location":"geometries/polytopes/","page":"Polytopes","title":"Polytopes","text":"Pyramid((0,0,0),(1,0,0),(1,1,0),(0,1,0),(0,0,1)) |> viz","category":"page"},{"location":"links/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"links/","page":"Index","title":"Index","text":"Below is the list of types and functions mentioned in the documentation.","category":"page"},{"location":"links/#Types","page":"Index","title":"Types","text":"","category":"section"},{"location":"links/","page":"Index","title":"Index","text":"Order = [:type]","category":"page"},{"location":"links/#Functions","page":"Index","title":"Functions","text":"","category":"section"},{"location":"links/","page":"Index","title":"Index","text":"Order = [:function]","category":"page"},{"location":"visualization/#Visualization","page":"Visualization","title":"Visualization","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"using Meshes # hide\nusing CoordRefSystems # hide\nimport CairoMakie as Mke # hide","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"The package exports a single viz command that can be used to add objects to the scene with a consistent set of options.","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"viz\nviz!","category":"page"},{"location":"visualization/#Meshes.viz","page":"Visualization","title":"Meshes.viz","text":"viz(object; [options])\n\nVisualize Meshes.jl object with various options.\n\nAvailable options\n\ncolor        - color of geometries\nalpha        - transparency in [0,1]\ncolormap     - color scheme/map from ColorSchemes.jl\ncolorrange   - minimum and maximum color values\nshowsegments - visualize segments\nsegmentcolor - color of segments\nsegmentsize  - width of segments\nshowpoints   - visualize points\npointmarker  - marker of points\npointcolor   - color of points\npointsize    - size of points\n\nThe option color can be a single scalar or a vector of scalars. For Mesh subtypes, the length of the vector of colors determines if the colors should be assigned to vertices or to elements.\n\nExamples\n\nDifferent coloring methods (vertex vs. element):\n\n# vertex coloring (i.e. linear interpolation)\nviz(mesh, color = 1:nvertices(mesh))\n\n# element coloring (i.e. discrete colors)\nviz(mesh, color = 1:nelements(mesh))\n\nDifferent strategies to show the boundary of geometries (showsegments vs. boundary):\n\n# visualize boundary with showsegments\nviz(polygon, showsegments = true)\n\n# visualize boundary with separate call\nviz(polygon)\nviz!(boundary(polygon))\n\nNotes\n\nThis function will only work in the presence of a Makie.jl backend via package extensions in Julia v1.9 or later versions of the language.\n\n\n\n\n\n","category":"function"},{"location":"visualization/#Meshes.viz!","page":"Visualization","title":"Meshes.viz!","text":"viz!(object; [options])\n\nVisualize Meshes.jl object in an existing scene with options forwarded to viz.\n\n\n\n\n\n","category":"function"},{"location":"visualization/#Geometries","page":"Visualization","title":"Geometries","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"We can visualize a single geometry or multiple geometries in a vector:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"triangles = rand(Triangle, 10, crs=Cartesian2D)\n\nviz(triangles, color = 1:10)","category":"page"},{"location":"visualization/#Domains","page":"Visualization","title":"Domains","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Alternatively, we can visualize domains with topological information such as Mesh and show facets efficiently:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"grid = CartesianGrid(10, 10, 10)\n\nviz(grid, showsegments = true, segmentcolor = :teal)","category":"page"},{"location":"tolerances/#Tolerances","page":"Tolerances","title":"Tolerances","text":"","category":"section"},{"location":"tolerances/","page":"Tolerances","title":"Tolerances","text":"The absolute tolerance used for floating point comparisons is hard-coded in the project to 1e-10 for Float64 and to 1f-5 for Float32. You can use ScopedValues.jl to customize these tolerance values in specific computations:","category":"page"},{"location":"tolerances/","page":"Tolerances","title":"Tolerances","text":"using Meshes\nusing ScopedValues\n\nwith(Meshes.ATOL64 => 1e-9, Meshes.ATOL32 => 1f-4) do\n  # do your computations with custom tolerances\nend","category":"page"},{"location":"io/#Input/Output","page":"Input/Output","title":"Input/Output","text":"","category":"section"},{"location":"io/","page":"Input/Output","title":"Input/Output","text":"The GeoIO.jl package can be used to load/save mesh data in various different formats, including VTK, GIS, PLY and many other formats. The package provides two functions GeoIO.load and GeoIO.save, which are self-explanatory:","category":"page"},{"location":"io/","page":"Input/Output","title":"Input/Output","text":"geotable = GeoIO.load(\"data.vtr\")","category":"page"},{"location":"io/","page":"Input/Output","title":"Input/Output","text":"GeoIO.save(\"data.vtu\", geotable)","category":"page"},{"location":"io/","page":"Input/Output","title":"Input/Output","text":"Please check the Geospatial Data Science with Julia book for more information.","category":"page"},{"location":"algorithms/clamping/#Clamping","page":"Clamping","title":"Clamping","text":"","category":"section"},{"location":"algorithms/clamping/","page":"Clamping","title":"Clamping","text":"Meshes adds methods to Julia's built-in clamp function. The additional methods clamp points to the edges of a box in any number of dimensions. The target points and boxes must have the same number of dimensions and the same numeric type.","category":"page"},{"location":"algorithms/clamping/","page":"Clamping","title":"Clamping","text":"clamp(::Point, ::Box)\nclamp(::PointSet, ::Box)","category":"page"},{"location":"algorithms/clamping/#Base.Math.clamp-Tuple{Point, Box}","page":"Clamping","title":"Base.Math.clamp","text":"clamp(point, box)\n\nClamp the coordinates of a Point to the edges of a Box.\n\nFor each dimension, coordinates outside of the box are moved to the nearest edge of the box. The point and box must have an equal number of dimensions.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/clamping/#Base.Math.clamp-Tuple{PointSet, Box}","page":"Clamping","title":"Base.Math.clamp","text":"clamp(pset, box)\n\nClamp each point in a PointSet to the edges of a Box, returning a new set of points.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/clamping/","page":"Clamping","title":"Clamping","text":"using Meshes # hide\nusing CoordRefSystems # hide\nimport CairoMakie as Mke # hide\n\n# set of 2D points to clamp\npoints = PointSet(rand(Point, 100, crs=Cartesian2D))\n\n# 2D box defining the clamping boundaries\nbox = Box((0.25, 0.25), (0.75, 0.75))\n\n# clamp point coordinates to the box edges\nclamped = clamp(points, box)\n\nfig = Mke.Figure(size=(800, 400))\nax = Mke.Axis(fig[1,1], title=\"unclamped\", aspect=1, limits=(0,1,0,1))\nviz!(ax, box)\nviz!(ax, points, color=:black, pointsize=6)\nax = Mke.Axis(fig[1,2], title=\"clamped\", aspect=1, limits=(0,1,0,1))\nviz!(ax, box)\nviz!(ax, clamped, color=:black, pointsize=6)\nfig","category":"page"},{"location":"algorithms/hulls/#Hulls","page":"Hulls","title":"Hulls","text":"","category":"section"},{"location":"algorithms/hulls/","page":"Hulls","title":"Hulls","text":"using Meshes # hide\nusing CoordRefSystems # hide\nimport CairoMakie as Mke # hide","category":"page"},{"location":"algorithms/hulls/","page":"Hulls","title":"Hulls","text":"hull\nconvexhull\nHullMethod\nGrahamScan\nJarvisMarch","category":"page"},{"location":"algorithms/hulls/#Meshes.hull","page":"Hulls","title":"Meshes.hull","text":"hull(points, method)\n\nCompute the hull of points with given method.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/hulls/#Meshes.convexhull","page":"Hulls","title":"Meshes.convexhull","text":"convexhull(object)\n\nConvex hull of object.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/hulls/#Meshes.HullMethod","page":"Hulls","title":"Meshes.HullMethod","text":"HullMethod\n\nA method for computing hulls of geometries.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/hulls/#Meshes.GrahamScan","page":"Hulls","title":"Meshes.GrahamScan","text":"GrahamScan()\n\nCompute the convex hull of a set of points or geometries using the Graham's scan algorithm. See https://en.wikipedia.org/wiki/Graham_scan.\n\nThe algorithm has complexity O(n*log(n)) where n is the number of points.\n\nReferences\n\nCormen et al. 2009. Introduction to Algorithms\n\n\n\n\n\n","category":"type"},{"location":"algorithms/hulls/#Meshes.JarvisMarch","page":"Hulls","title":"Meshes.JarvisMarch","text":"JarvisMarch()\n\nCompute the convex hull of a set of points or geometries using the Jarvis's march algorithm. See https://en.wikipedia.org/wiki/Giftwrappingalgorithm.\n\nThe algorithm has complexity O(n*h) where n is the number of points and h is the number of points in the hull.\n\nReferences\n\nJarvis 1973. On the identification of the convex hull of a finite set of points in the plane\n\n\n\n\n\n","category":"type"},{"location":"algorithms/hulls/","page":"Hulls","title":"Hulls","text":"pset = PointSet(rand(Point, 100, crs=Cartesian2D))\nchul = convexhull(pset)\n\nfig = Mke.Figure(size = (800, 400))\nviz(fig[1,1], chul)\nviz!(fig[1,1], pset, color = :black)\nfig","category":"page"},{"location":"algorithms/hulls/","page":"Hulls","title":"Hulls","text":"box  = Box((-1, -1), (0, 0))\nball = Ball((0, 0), (1))\ngset = GeometrySet([box, ball])\nchul = convexhull(gset)\n\nfig = Mke.Figure(size = (800, 400))\nviz(fig[1,1], chul)\nviz!(fig[1,1], boundary(box), color = :gray)\nviz!(fig[1,1], boundary(ball), color = :gray)\nfig","category":"page"},{"location":"algorithms/merging/#Merging","page":"Merging","title":"Merging","text":"","category":"section"},{"location":"algorithms/merging/","page":"Merging","title":"Merging","text":"Geometries and meshes can be merged into a single geometric object as illustrated in the following example. The resulting type depends on the combination of input types, and can be a Mesh or Multi geometry.","category":"page"},{"location":"algorithms/merging/","page":"Merging","title":"Merging","text":"merge(::Mesh, ::Mesh)","category":"page"},{"location":"algorithms/merging/#Base.merge-Tuple{Mesh, Mesh}","page":"Merging","title":"Base.merge","text":"merge(object₁, object₂)\n\nMerge object₁ with object₂, i.e. concatenate the vertices and adjust the connectivities accordingly.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/merging/","page":"Merging","title":"Merging","text":"using Meshes # hide\nimport CairoMakie as Mke # hide\n\ng = CartesianGrid(2, 2)\nt = Triangle((3, 0), (4, 0), (3, 1))\n\nm = merge(g, t)","category":"page"},{"location":"algorithms/partitioning/#Partition","page":"Partition","title":"Partition","text":"","category":"section"},{"location":"algorithms/partitioning/","page":"Partition","title":"Partition","text":"partition\nPartitionMethod","category":"page"},{"location":"algorithms/partitioning/#Meshes.partition","page":"Partition","title":"Meshes.partition","text":"partition([rng], object, method)\n\nPartition object with partition method. Optionally, specify random number generator rng.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/partitioning/#Meshes.PartitionMethod","page":"Partition","title":"Meshes.PartitionMethod","text":"PartitionMethod\n\nA method for partitioning domain/data objects.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/partitioning/#Uniform","page":"Partition","title":"Uniform","text":"","category":"section"},{"location":"algorithms/partitioning/","page":"Partition","title":"Partition","text":"UniformPartition","category":"page"},{"location":"algorithms/partitioning/#Meshes.UniformPartition","page":"Partition","title":"Meshes.UniformPartition","text":"UniformPartition(k, [shuffle])\n\nA method for partitioning spatial objects uniformly into k subsets of approximately equal size. Optionally shuffle the data (default to true).\n\n\n\n\n\n","category":"type"},{"location":"algorithms/partitioning/#Fraction","page":"Partition","title":"Fraction","text":"","category":"section"},{"location":"algorithms/partitioning/","page":"Partition","title":"Partition","text":"FractionPartition","category":"page"},{"location":"algorithms/partitioning/#Meshes.FractionPartition","page":"Partition","title":"Meshes.FractionPartition","text":"FractionPartition(fraction, shuffle=true)\n\nA method for partitioning spatial objects according to a given fraction. Optionally shuffle elements before partitioning.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/partitioning/#Block","page":"Partition","title":"Block","text":"","category":"section"},{"location":"algorithms/partitioning/","page":"Partition","title":"Partition","text":"BlockPartition","category":"page"},{"location":"algorithms/partitioning/#Meshes.BlockPartition","page":"Partition","title":"Meshes.BlockPartition","text":"BlockPartition(sides; neighbors=false)\n\nA method for partitioning spatial objects into blocks of given sides. Optionally, compute the neighbors of a block as the metadata.\n\nBlockPartition(side₁, side₂, ..., sideₙ; neighbors=false)\n\nAlternatively, specify the sides side₁, side₂, ..., sideₙ.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/partitioning/#Bisect-Point","page":"Partition","title":"Bisect-Point","text":"","category":"section"},{"location":"algorithms/partitioning/","page":"Partition","title":"Partition","text":"BisectPointPartition","category":"page"},{"location":"algorithms/partitioning/#Meshes.BisectPointPartition","page":"Partition","title":"Meshes.BisectPointPartition","text":"BisectPointPartition(normal, point)\n\nA method for partitioning spatial objects into two half spaces defined by a normal direction and a reference point.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/partitioning/#Bisect-Fraction","page":"Partition","title":"Bisect-Fraction","text":"","category":"section"},{"location":"algorithms/partitioning/","page":"Partition","title":"Partition","text":"BisectFractionPartition","category":"page"},{"location":"algorithms/partitioning/#Meshes.BisectFractionPartition","page":"Partition","title":"Meshes.BisectFractionPartition","text":"BisectFractionPartition(normal, fraction=0.5, maxiter=10)\n\nA method for partitioning spatial objects into two half spaces defined by a normal direction and a fraction of points. The partition is returned within maxiter bisection iterations.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/partitioning/#Ball","page":"Partition","title":"Ball","text":"","category":"section"},{"location":"algorithms/partitioning/","page":"Partition","title":"Partition","text":"BallPartition","category":"page"},{"location":"algorithms/partitioning/#Meshes.BallPartition","page":"Partition","title":"Meshes.BallPartition","text":"BallPartition(radius; metric=Euclidean())\n\nA method for partitioning spatial objects into balls of a given radius using a metric.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/partitioning/#Plane","page":"Partition","title":"Plane","text":"","category":"section"},{"location":"algorithms/partitioning/","page":"Partition","title":"Partition","text":"PlanePartition","category":"page"},{"location":"algorithms/partitioning/#Meshes.PlanePartition","page":"Partition","title":"Meshes.PlanePartition","text":"PlanePartition(normal; [tol])\n\nA method for partitioning spatial objects into a family of hyperplanes defined by a normal direction. Two points x and y belong to the same hyperplane when (x - y) ⋅ normal < tol.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/partitioning/#Direction","page":"Partition","title":"Direction","text":"","category":"section"},{"location":"algorithms/partitioning/","page":"Partition","title":"Partition","text":"DirectionPartition","category":"page"},{"location":"algorithms/partitioning/#Meshes.DirectionPartition","page":"Partition","title":"Meshes.DirectionPartition","text":"DirectionPartition(direction; [tol])\n\nA method for partitioning spatial objects along a given direction with bandwidth tolerance tol.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/partitioning/#Predicate","page":"Partition","title":"Predicate","text":"","category":"section"},{"location":"algorithms/partitioning/","page":"Partition","title":"Partition","text":"PredicatePartition","category":"page"},{"location":"algorithms/partitioning/#Meshes.PredicatePartition","page":"Partition","title":"Meshes.PredicatePartition","text":"PredicatePartition(predicate)\n\nA method for partitioning spatial objects with a given predicate function. Two locations i and j are part of the same subset whenever predicate(i, j) == true\n\n\n\n\n\n","category":"type"},{"location":"algorithms/partitioning/#SpatialPredicate","page":"Partition","title":"SpatialPredicate","text":"","category":"section"},{"location":"algorithms/partitioning/","page":"Partition","title":"Partition","text":"SpatialPredicatePartition","category":"page"},{"location":"algorithms/partitioning/#Meshes.SpatialPredicatePartition","page":"Partition","title":"Meshes.SpatialPredicatePartition","text":"SpatialPredicatePartition(predicate)\n\nA method for partitioning spatial objects with a given spatial predicate function. Two coordinates x and y are part of the same subset whenever predicate(x, y) == true.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/partitioning/#Product","page":"Partition","title":"Product","text":"","category":"section"},{"location":"algorithms/partitioning/","page":"Partition","title":"Partition","text":"ProductPartition","category":"page"},{"location":"algorithms/partitioning/#Meshes.ProductPartition","page":"Partition","title":"Meshes.ProductPartition","text":"ProductPartition(p₁, p₂)\n\nA method for partitioning spatial objects using the product of two partitioning methods p₁ and p₂.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/partitioning/#Hierarchical","page":"Partition","title":"Hierarchical","text":"","category":"section"},{"location":"algorithms/partitioning/","page":"Partition","title":"Partition","text":"HierarchicalPartition","category":"page"},{"location":"algorithms/partitioning/#Meshes.HierarchicalPartition","page":"Partition","title":"Meshes.HierarchicalPartition","text":"HierarchicalPartition(first, second)\n\nA partitioning method in which a first partition is applied and then a second partition is applied to each subset of the first.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/sideof/#Sideof","page":"Sideof","title":"Sideof","text":"","category":"section"},{"location":"algorithms/sideof/","page":"Sideof","title":"Sideof","text":"The sideof function can be used to efficiently query the side of multiple points with respect to a given geometry or mesh.","category":"page"},{"location":"algorithms/sideof/","page":"Sideof","title":"Sideof","text":"SideType\nsideof(::Point, ::Line)\nsideof(::Point, ::Ring)\nsideof(::Point, ::Mesh)","category":"page"},{"location":"algorithms/sideof/#Meshes.SideType","page":"Sideof","title":"Meshes.SideType","text":"IntersectionType\n\nThe different types of sides that a point may lie in relation to a boundary geometry or mesh. Type SideType in a Julia session to see the full list.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/sideof/#Meshes.sideof-Tuple{Point, Line}","page":"Sideof","title":"Meshes.sideof","text":"sideof(point, line)\n\nDetermines on which side the point is in relation to the line. Possible results are LEFT, RIGHT or ON the line.\n\nNotes\n\nAssumes the orientation of Segment(line(0), line(1)).\n\n\n\n\n\n","category":"method"},{"location":"algorithms/sideof/#Meshes.sideof-Tuple{Point, Ring}","page":"Sideof","title":"Meshes.sideof","text":"sideof(point, ring)\n\nDetermines on which side the point is in relation to the ring. Possible results are IN, OUT or ON the ring.\n\nReferences\n\nHao et al. 2018. Optimal Reliable Point-in-Polygon Test and Differential Coding Boolean Operations on Polygons\n\n\n\n\n\n","category":"method"},{"location":"algorithms/sideof/#Meshes.sideof-Tuple{Point, Mesh}","page":"Sideof","title":"Meshes.sideof","text":"sideof(point, mesh)\n\nDetermines on which side the point is in relation to the surface mesh. Possible results are IN or OUT the mesh.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/sideof/","page":"Sideof","title":"Sideof","text":"using Meshes # hide\n\nsideof(Point(0, 0), Line((1, 0), (1, 1)))","category":"page"},{"location":"algorithms/sideof/","page":"Sideof","title":"Sideof","text":"points = [Point(0, 0), Point(0.2, 0.2), Point(2, 1)]\npolygon = Triangle((0, 0), (1, 0), (0, 1))\n\nsideof(points, boundary(polygon))","category":"page"},{"location":"about/license/","page":"License","title":"License","text":"The Meshes.jl project is licensed under the MIT license:","category":"page"},{"location":"about/license/","page":"License","title":"License","text":"Copyright (c) 2019-2020 Júlio Hoffimann, Simon Danisch, Arsh Sharma, Anshul Singhvi,\nMartijn Visser, Daniel Schwabeneder, F Freyer, Steve Kelly, Tim Holy, Matija Čufar,\nBenoît Legat, Erik Schenetter, Jan Weidner, Mohamed Tarek, Paul Jurczak,\nZachary P. Christensen, Andrew Bylard, Yuval\n\nLicensed under the MIT license.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.","category":"page"},{"location":"algorithms/simplification/#Simplification","page":"Simplification","title":"Simplification","text":"","category":"section"},{"location":"algorithms/simplification/","page":"Simplification","title":"Simplification","text":"using Meshes # hide\nimport CairoMakie as Mke # hide","category":"page"},{"location":"algorithms/simplification/","page":"Simplification","title":"Simplification","text":"simplify\nSimplificationMethod","category":"page"},{"location":"algorithms/simplification/#Meshes.simplify","page":"Simplification","title":"Meshes.simplify","text":"simplify(object, method)\n\nSimplify geometric object with given method.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/simplification/#Meshes.SimplificationMethod","page":"Simplification","title":"Meshes.SimplificationMethod","text":"SimplificationMethod\n\nA method for simplifying geometric objects.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/simplification/#SelingerSimplification","page":"Simplification","title":"SelingerSimplification","text":"","category":"section"},{"location":"algorithms/simplification/","page":"Simplification","title":"Simplification","text":"SelingerSimplification","category":"page"},{"location":"algorithms/simplification/#Meshes.SelingerSimplification","page":"Simplification","title":"Meshes.SelingerSimplification","text":"SelingerSimplification(τ)\n\nSelinger's simplification algorithm with tolerance τ in length units (default to meter).\n\nThe higher is the tolerance, the more aggressive is the simplification.\n\nReferences\n\nSelingerSimplification, P. 2003. Potrace: A polygon-based tracing algorithm\n\n\n\n\n\n","category":"type"},{"location":"algorithms/simplification/","page":"Simplification","title":"Simplification","text":"poly = PolyArea([(0.22926679, 0.47329807), (0.23094065, 0.44913536), (0.2569517, 0.38217533),\n                 (0.3072999, 0.272418), (0.34814754, 0.18421611), (0.37949452, 0.11756973),\n                 (0.4013409, 0.07247882), (0.41368666, 0.048943404), (0.42597583, 0.031655528),\n                 (0.4382084, 0.0206152), (0.45038435, 0.015822414), (0.4625037, 0.017277176),\n                 (0.47175184, 0.02439156), (0.47812873, 0.03716557), (0.4816344, 0.055599205),\n                 (0.48226887, 0.07969247), (0.48172843, 0.10446181), (0.4800131, 0.12990724),\n                 (0.47712287, 0.15602873), (0.47305775, 0.18282633), (0.47093934, 0.20558843),\n                 (0.47076762, 0.22431506), (0.47254258, 0.23900622), (0.47626427, 0.24966191),\n                 (0.47768936, 0.25845313), (0.47681788, 0.26537988), (0.4736498, 0.27044216),\n                 (0.46818516, 0.27363995), (0.4613889, 0.27232954), (0.45326096, 0.2665109),\n                 (0.44380143, 0.256184), (0.43301025, 0.24134888), (0.4246466, 0.22978415),\n                 (0.41871038, 0.22148979), (0.4152017, 0.21646582), (0.4141205, 0.21471222),\n                 (0.41227448, 0.21589448), (0.40966362, 0.22001258), (0.40628797, 0.22706655),\n                 (0.40214747, 0.23705636), (0.40200475, 0.24653101), (0.40585983, 0.25549048),\n                 (0.41371268, 0.2639348), (0.4255633, 0.2718639), (0.4378565, 0.28495985),\n                 (0.4505922, 0.30322257), (0.46377045, 0.32665208), (0.47739124, 0.35524836),\n                 (0.5046394, 0.36442512), (0.5455148, 0.35418236), (0.60001767, 0.32452005),\n                 (0.66814786, 0.27543822), (0.7186763, 0.24664374), (0.75160307, 0.23813659),\n                 (0.76692814, 0.2499168), (0.7646515, 0.28198436), (0.7769703, 0.29925033),\n                 (0.8038847, 0.3017147), (0.84539455, 0.28937748), (0.9015, 0.26223865),\n                 (0.94408435, 0.24899776), (0.9731477, 0.24965483), (0.98869, 0.26420987),\n                 (0.9907113, 0.29266283), (0.9849871, 0.31338844), (0.97151726, 0.32638666),\n                 (0.950302, 0.3316575), (0.9213412, 0.32920095), (0.8798396, 0.34078467),\n                 (0.8257972, 0.36640862), (0.7592141, 0.40607283), (0.6800901, 0.4597773),\n                 (0.6450007, 0.49104902), (0.6539457, 0.49988794), (0.7069251, 0.48629412),\n                 (0.803939, 0.45026752), (0.877913, 0.4226481), (0.9288472, 0.40343583),\n                 (0.9567415, 0.39263073), (0.961596, 0.39023277), (0.9419039, 0.40523484),\n                 (0.89766514, 0.43763688), (0.8288798, 0.48743892), (0.7355478, 0.55464095),\n                 (0.6655121, 0.60063523), (0.6187727, 0.6254217), (0.5953296, 0.62900037),\n                 (0.5951828, 0.6113712), (0.57516366, 0.60261106), (0.53527224, 0.6027198),\n                 (0.4755085, 0.6116975), (0.3958725, 0.6295441), (0.33913234, 0.6398651),\n                 (0.30528808, 0.6426605), (0.2943397, 0.6379303), (0.30628717, 0.6256744),\n                 (0.32149008, 0.6093727), (0.33994842, 0.5890249), (0.36166218, 0.5646312),\n                 (0.38663134, 0.5361916), (0.3919681, 0.520893), (0.3776725, 0.5187355),\n                 (0.34374446, 0.52971905), (0.29018405, 0.5538437), (0.25439468, 0.5678829),\n                 (0.2363764, 0.5718367), (0.23612918, 0.56570506), (0.25365302, 0.549488),\n                 (0.2733971, 0.5246488), (0.29536137, 0.49118724), (0.3195459, 0.4491035),\n                 (0.34595063, 0.39839754), (0.3647463, 0.3590396), (0.37593287, 0.33102974),\n                 (0.37951034, 0.31436795), (0.37547874, 0.30905423), (0.36070493, 0.3204269),\n                 (0.33518887, 0.348486), (0.29893062, 0.3932315), (0.25193012, 0.45466346)])\n\nsimp1 = simplify(poly, SelingerSimplification(0.01))\nsimp2 = simplify(poly, SelingerSimplification(0.05))\nsimp3 = simplify(poly, SelingerSimplification(0.10))\n\nfig = Mke.Figure(size = (800, 800))\nviz(fig[1,1], poly)\nviz(fig[1,2], simp1)\nviz(fig[2,1], simp2)\nviz(fig[2,2], simp3)\nfig","category":"page"},{"location":"algorithms/simplification/#DouglasPeuckerSimplification","page":"Simplification","title":"DouglasPeuckerSimplification","text":"","category":"section"},{"location":"algorithms/simplification/","page":"Simplification","title":"Simplification","text":"DouglasPeuckerSimplification","category":"page"},{"location":"algorithms/simplification/#Meshes.DouglasPeuckerSimplification","page":"Simplification","title":"Meshes.DouglasPeuckerSimplification","text":"DouglasPeuckerSimplification(τ)\n\nDouglas-Peucker's simplification algorithm with tolerance τ in length units (default to meter).\n\nThe higher is the tolerance, the more aggressive is the simplification.\n\nReferences\n\nDouglas, D. and Peucker, T. 1973. Algorithms for the Reduction of the Number of Points Required to Represent a Digitized Line or its Caricature\n\n\n\n\n\n","category":"type"},{"location":"algorithms/simplification/","page":"Simplification","title":"Simplification","text":"simp1 = simplify(poly, DouglasPeuckerSimplification(0.01))\nsimp2 = simplify(poly, DouglasPeuckerSimplification(0.05))\nsimp3 = simplify(poly, DouglasPeuckerSimplification(0.10))\n\nfig = Mke.Figure(size = (800, 800))\nviz(fig[1,1], poly)\nviz(fig[1,2], simp1)\nviz(fig[2,1], simp2)\nviz(fig[2,2], simp3)\nfig","category":"page"},{"location":"algorithms/simplification/#MinMaxSimplification","page":"Simplification","title":"MinMaxSimplification","text":"","category":"section"},{"location":"algorithms/simplification/","page":"Simplification","title":"Simplification","text":"MinMaxSimplification","category":"page"},{"location":"algorithms/simplification/#Meshes.MinMaxSimplification","page":"Simplification","title":"Meshes.MinMaxSimplification","text":"MinMaxSimplification(method; min=3, max=typemax(Int), maxiter=10)\n\nSimplify geometries with binary search algorithm and a parent simplification method.\n\nThe simplification is performed until the number of vertices is in the [min, max] range or until a maximum number of iterations maxiter is reached.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/simplification/","page":"Simplification","title":"Simplification","text":"simp1 = simplify(poly, MinMaxSimplification(DouglasPeuckerSimplification, max=20))\nsimp2 = simplify(poly, MinMaxSimplification(DouglasPeuckerSimplification, max=10))\nsimp3 = simplify(poly, MinMaxSimplification(DouglasPeuckerSimplification, max=5))\n\nfig = Mke.Figure(size = (800, 800))\nviz(fig[1,1], poly)\nviz(fig[1,2], simp1)\nviz(fig[2,1], simp2)\nviz(fig[2,2], simp3)\nfig","category":"page"},{"location":"algorithms/tesselation/#Tesselation","page":"Tesselation","title":"Tesselation","text":"","category":"section"},{"location":"algorithms/tesselation/","page":"Tesselation","title":"Tesselation","text":"using Meshes # hide\nusing CoordRefSystems # hide\nimport CairoMakie as Mke # hide","category":"page"},{"location":"algorithms/tesselation/","page":"Tesselation","title":"Tesselation","text":"tesselate\nTesselationMethod","category":"page"},{"location":"algorithms/tesselation/#Meshes.tesselate","page":"Tesselation","title":"Meshes.tesselate","text":"tesselate(pointset, [method])\n\nTesselate pointset with tesselation method.\n\nIf the method is ommitted, a default algorithm is used.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/tesselation/#Meshes.TesselationMethod","page":"Tesselation","title":"Meshes.TesselationMethod","text":"DiscretizationMethod\n\nA method for tesselating point sets into meshes.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/tesselation/#DelaunayTesselation","page":"Tesselation","title":"DelaunayTesselation","text":"","category":"section"},{"location":"algorithms/tesselation/","page":"Tesselation","title":"Tesselation","text":"DelaunayTesselation","category":"page"},{"location":"algorithms/tesselation/#Meshes.DelaunayTesselation","page":"Tesselation","title":"Meshes.DelaunayTesselation","text":"DelaunayTesselation([rng])\n\nUnconstrained Delaunay tesselation of point sets. Optionally, specify the random number generator rng.\n\nReferences\n\nCheng et al. 2012. Delaunay Mesh Generation\n\nNotes\n\nWraps DelaunayTriangulation.jl. For any internal errors, file an issue at  DelaunayTriangulation.jl\n\n\n\n\n\n","category":"type"},{"location":"algorithms/tesselation/","page":"Tesselation","title":"Tesselation","text":"points = rand(Point, 100, crs=Cartesian2D)\n\nmesh = tesselate(points, DelaunayTesselation())\n\nviz(mesh, showsegments = true)\nviz!(points, color = :red)\nMke.current_figure()","category":"page"},{"location":"algorithms/tesselation/#VoronoiTesselation","page":"Tesselation","title":"VoronoiTesselation","text":"","category":"section"},{"location":"algorithms/tesselation/","page":"Tesselation","title":"Tesselation","text":"VoronoiTesselation","category":"page"},{"location":"algorithms/tesselation/#Meshes.VoronoiTesselation","page":"Tesselation","title":"Meshes.VoronoiTesselation","text":"VoronoiTesselation([rng])\n\nUnconstrained Voronoi tesselation of point sets. Optionally, specify the random number generator rng.\n\nReferences\n\nCheng et al. 2012. Delaunay Mesh Generation\n\nNotes\n\nWraps DelaunayTriangulation.jl. For any internal errors, file an issue at  DelaunayTriangulation.jl\n\n\n\n\n\n","category":"type"},{"location":"algorithms/tesselation/","page":"Tesselation","title":"Tesselation","text":"points = rand(Point, 100, crs=Cartesian2D)\n\nmesh = tesselate(points, VoronoiTesselation())\n\nviz(mesh, showsegments = true)\nviz!(points, color = :red)\nMke.current_figure()","category":"page"},{"location":"algorithms/coarsening/#Coarsening","page":"Coarsening","title":"Coarsening","text":"","category":"section"},{"location":"algorithms/coarsening/","page":"Coarsening","title":"Coarsening","text":"using Meshes # hide\nimport CairoMakie as Mke # hide","category":"page"},{"location":"algorithms/coarsening/","page":"Coarsening","title":"Coarsening","text":"coarsen\nCoarseningMethod","category":"page"},{"location":"algorithms/coarsening/#Meshes.coarsen","page":"Coarsening","title":"Meshes.coarsen","text":"coarsen(mesh, method)\n\nCoarsen mesh with coarsening method.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/coarsening/#Meshes.CoarseningMethod","page":"Coarsening","title":"Meshes.CoarseningMethod","text":"CoarseningMethod\n\nA method for coarsening meshes.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/coarsening/#RegularCoarsening","page":"Coarsening","title":"RegularCoarsening","text":"","category":"section"},{"location":"algorithms/coarsening/","page":"Coarsening","title":"Coarsening","text":"RegularCoarsening","category":"page"},{"location":"algorithms/coarsening/#Meshes.RegularCoarsening","page":"Coarsening","title":"Meshes.RegularCoarsening","text":"RegularCoarsening(f₁, f₂, ..., fₙ)\n\nCoarsen each dimension of the grid by given factors f₁, f₂, ..., fₙ.\n\nExamples\n\ncoarsen(grid2D, RegularCoarsening(2, 3))\ncoarsen(grid3D, RegularCoarsening(2, 3, 1))\n\n\n\n\n\n","category":"type"},{"location":"algorithms/coarsening/","page":"Coarsening","title":"Coarsening","text":"grid = CartesianGrid(100, 100)\n\n# refine three times\ncor1 = coarsen(grid, RegularCoarsening(2, 2))\ncor2 = coarsen(cor1, RegularCoarsening(3, 2))\ncor3 = coarsen(cor2, RegularCoarsening(2, 3))\n\nfig = Mke.Figure(size = (800, 800))\nviz(fig[1,1], grid, showsegments = true)\nviz(fig[1,2], cor1, showsegments = true)\nviz(fig[2,1], cor2, showsegments = true)\nviz(fig[2,2], cor3, showsegments = true)\nfig","category":"page"},{"location":"algorithms/winding/#Winding","page":"Winding","title":"Winding","text":"","category":"section"},{"location":"algorithms/winding/","page":"Winding","title":"Winding","text":"The winding number is intimately connected to the sideof function, which is used more often in applications.","category":"page"},{"location":"algorithms/winding/","page":"Winding","title":"Winding","text":"winding","category":"page"},{"location":"algorithms/winding/#Meshes.winding","page":"Winding","title":"Meshes.winding","text":"winding(points, object)\n\nGeneralized winding number of points with respect to the geometric object.\n\nReferences\n\nBarill et al. 2018. Fast winding numbers for soups and clouds\nJacobson et al. 2013. Robust inside-outside segmentation using generalized winding numbers\nOosterom, A. & Strackee, J. 1983. The Solid Angle of a Plane Triangle\n\n\n\n\n\n","category":"function"},{"location":"algorithms/winding/","page":"Winding","title":"Winding","text":"using Meshes # hide\n\npoints = [Point(0, 0), Point(0.2, 0.2), Point(2, 1)]\npolygon = Triangle((0, 0), (1, 0), (0, 1))\n\nwinding(points, boundary(polygon))","category":"page"},{"location":"domains/trajectories/#Trajectories","page":"Trajectories","title":"Trajectories","text":"","category":"section"},{"location":"domains/trajectories/","page":"Trajectories","title":"Trajectories","text":"using Meshes # hide\nimport CairoMakie as Mke # hide","category":"page"},{"location":"domains/trajectories/","page":"Trajectories","title":"Trajectories","text":"Trajectories of geometries are special geometry sets with one-dimensional grid topology. They are often used in geosciences to represent drill holes, wells, etc.","category":"page"},{"location":"domains/trajectories/","page":"Trajectories","title":"Trajectories","text":"CylindricalTrajectory","category":"page"},{"location":"domains/trajectories/#Meshes.CylindricalTrajectory","page":"Trajectories","title":"Meshes.CylindricalTrajectory","text":"CylindricalTrajectory(centroids, radius)\n\nTrajectory of cylinders of given radius positioned at the centroids.\n\n\n\n\n\n","category":"type"},{"location":"domains/trajectories/","page":"Trajectories","title":"Trajectories","text":"# construct centroids along Bezier curve\nb = BezierCurve([(0, 0, 0), (3, 3, 0), (3, 0, 7)])\nc = [b(t) for t in range(0, stop=1, length=20)]\n\n# cylindrical trajectory with radius 2\nCylindricalTrajectory(c, 2) |> viz","category":"page"},{"location":"algorithms/clipping/#Clipping","page":"Clipping","title":"Clipping","text":"","category":"section"},{"location":"algorithms/clipping/","page":"Clipping","title":"Clipping","text":"using Meshes # hide\nimport CairoMakie as Mke # hide","category":"page"},{"location":"algorithms/clipping/","page":"Clipping","title":"Clipping","text":"clip\nClippingMethod","category":"page"},{"location":"algorithms/clipping/#Meshes.clip","page":"Clipping","title":"Meshes.clip","text":"clip(geometry, other, method)\n\nClip the subject geometry with other geometry using clipping method.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/clipping/#Meshes.ClippingMethod","page":"Clipping","title":"Meshes.ClippingMethod","text":"ClippingMethod\n\nA method for clipping geometries with other geometries.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/clipping/#SutherlandHodgman","page":"Clipping","title":"SutherlandHodgman","text":"","category":"section"},{"location":"algorithms/clipping/","page":"Clipping","title":"Clipping","text":"SutherlandHodgman","category":"page"},{"location":"algorithms/clipping/#Meshes.SutherlandHodgman","page":"Clipping","title":"Meshes.SutherlandHodgman","text":"SutherlandHodgman()\n\nThe Sutherland-Hodgman algorithm for clipping polygons.\n\nReferences\n\nSutherland, I.E. & Hodgman, G.W. 1974. Reentrant Polygon Clipping\n\nNotes\n\nThe algorithm assumes that the clipping geometry is convex.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/clipping/","page":"Clipping","title":"Clipping","text":"# polygon to clip\nouter = Ring((8, 0), (4, 8), (2, 8), (-2, 0), (0, 0), (1, 2), (5, 2), (6, 0))\ninner = Ring((4, 4), (2, 4), (3, 6))\npoly = PolyArea([outer, inner])\n\n# clipping geometry\nother = Box((0,1), (3,7))\n\n# clipped polygon\nclipped = clip(poly, other, SutherlandHodgman())\n\nviz(poly)\nviz!(other, color = :black, alpha = 0.2)\nviz!(boundary(clipped), color = :red, segmentsize = 3)\nMke.current_figure()","category":"page"},{"location":"transforms/#Transforms","page":"Transforms","title":"Transforms","text":"","category":"section"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"using Meshes # hide\nusing CoordRefSystems # hide\nimport CairoMakie as Mke # hide","category":"page"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"Geometric (e.g. coordinates) transforms are implemented according to the TransformsBase.jl interface. Please read their documentation for more details.","category":"page"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"GeometricTransform\nCoordinateTransform","category":"page"},{"location":"transforms/#Meshes.GeometricTransform","page":"Transforms","title":"Meshes.GeometricTransform","text":"GeometricTransform\n\nA method to transform the geometry (e.g. coordinates) of objects. See https://en.wikipedia.org/wiki/Geometric_transformation.\n\n\n\n\n\n","category":"type"},{"location":"transforms/#Meshes.CoordinateTransform","page":"Transforms","title":"Meshes.CoordinateTransform","text":"CoordinateTransform\n\nA method to transform the coordinates of objects. See https://en.wikipedia.org/wiki/List_of_common_coordinate_transformations.\n\n\n\n\n\n","category":"type"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"Some transforms have an inverse that can be created with the inverse function. The function isinvertible can be used to check if a transform is invertible.","category":"page"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"inverse\nisinvertible","category":"page"},{"location":"transforms/#TransformsBase.inverse","page":"Transforms","title":"TransformsBase.inverse","text":"inverse(transform)\n\nReturns the inverse transform of the transform.\n\nSee also isinvertible.\n\n\n\n\n\n","category":"function"},{"location":"transforms/#TransformsBase.isinvertible","page":"Transforms","title":"TransformsBase.isinvertible","text":"isinvertible(transform)\n\nTells whether or not the transform is invertible, i.e. whether it implements the inverse function. Defaults to false for new transform types.\n\nTransforms can be invertible in the mathematical sense, i.e., there exists a one-to-one mapping between input and output spaces.\n\nSee also inverse, isrevertible.\n\n\n\n\n\n","category":"function"},{"location":"transforms/#Rotate","page":"Transforms","title":"Rotate","text":"","category":"section"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"Rotate","category":"page"},{"location":"transforms/#Meshes.Rotate","page":"Transforms","title":"Meshes.Rotate","text":"Rotate(rot)\n\nRotate geometry or mesh with rotation rot from Rotations.jl.\n\nExamples\n\nRotate(one(RotXYZ{Float64}))  # Generate identity rotation\nRotate(AngleAxis(0.2, 1.0, 0.0, 0.0))  # Rotate 0.2 radians around X-axis\nRotate(rand(QuatRotation{Float64}))  # Generate random rotation\n\n\n\n\n\n","category":"type"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"using Rotations: Angle2d\n\ngrid = CartesianGrid(10, 10)\n\nmesh = grid |> Rotate(Angle2d(π/4))\n\nfig = Mke.Figure(size = (800, 400))\nviz(fig[1,1], grid)\nviz(fig[1,2], mesh)\nfig","category":"page"},{"location":"transforms/#Translate","page":"Transforms","title":"Translate","text":"","category":"section"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"Translate","category":"page"},{"location":"transforms/#Meshes.Translate","page":"Transforms","title":"Meshes.Translate","text":"Translate(o₁, o₂, ...)\n\nTranslate coordinates of geometry or mesh by given offsets o₁, o₂, ....\n\n\n\n\n\n","category":"type"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"grid = CartesianGrid(10, 10)\n\nmesh = grid |> Translate(10., 20.)\n\nfig = Mke.Figure(size = (800, 400))\nviz(fig[1,1], grid)\nviz(fig[1,2], mesh)\nfig","category":"page"},{"location":"transforms/#Scale","page":"Transforms","title":"Scale","text":"","category":"section"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"Scale","category":"page"},{"location":"transforms/#Meshes.Scale","page":"Transforms","title":"Meshes.Scale","text":"Scale(s₁, s₂, ...)\n\nScale geometry or domain with strictly positive scaling factors s₁, s₂, ....\n\nExamples\n\nScale(1.0, 2.0, 3.0)\n\n\n\n\n\n","category":"type"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"grid = CartesianGrid(10, 10)\n\nmesh = grid |> Scale(2., 3.)\n\nfig = Mke.Figure(size = (800, 400))\nviz(fig[1,1], grid)\nviz(fig[1,2], mesh)\nfig","category":"page"},{"location":"transforms/#Affine","page":"Transforms","title":"Affine","text":"","category":"section"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"Affine","category":"page"},{"location":"transforms/#Meshes.Affine","page":"Transforms","title":"Meshes.Affine","text":"Affine(A, b)\n\nAffine transform Ax + b with matrix A and vector b.\n\nExamples\n\nAffine(AngleAxis(0.2, 1.0, 0.0, 0.0), [-2, 2, 2])\nAffine(Angle2d(π / 2), SVector(2, -2))\nAffine([0 -1; 1 0], [-2, 2])\n\n\n\n\n\n","category":"type"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"grid = CartesianGrid(10, 10)\n\nmesh = grid |> Affine(Angle2d(π/4), [10., 20.])\n\nfig = Mke.Figure(size = (800, 400))\nviz(fig[1,1], grid)\nviz(fig[1,2], mesh)\nfig","category":"page"},{"location":"transforms/#Stretch","page":"Transforms","title":"Stretch","text":"","category":"section"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"Stretch","category":"page"},{"location":"transforms/#Meshes.Stretch","page":"Transforms","title":"Meshes.Stretch","text":"Stretch(s₁, s₂, ...)\n\nStretch geometry or domain outwards with strictly positive scaling factors s₁, s₂, ....\n\nExamples\n\nStretch(1.0, 2.0, 3.0)\n\n\n\n\n\n","category":"type"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"grid = CartesianGrid(10, 10)\n\nmesh = grid |> Stretch(2., 3.)\n\nfig = Mke.Figure(size = (800, 400))\nviz(fig[1,1], grid)\nviz(fig[1,2], mesh)\nfig","category":"page"},{"location":"transforms/#StdCoords","page":"Transforms","title":"StdCoords","text":"","category":"section"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"StdCoords","category":"page"},{"location":"transforms/#Meshes.StdCoords","page":"Transforms","title":"Meshes.StdCoords","text":"StdCoords()\n\nStandardize coordinates of all geometries to the interval [-0.5, 0.5].\n\nExamples\n\njulia> CartesianGrid(10, 10) |> StdCoords()\n10×10 CartesianGrid{2,Float64}\n  minimum: Point(-0.5, -0.5)\n  maximum: Point(0.5, 0.5)\n  spacing: (0.1, 0.1)\n\n\n\n\n\n","category":"type"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"# Cartesian grid with coordinates [0,10] x [0,10]\ngrid = CartesianGrid(10, 10)\n\n# scale coordinates to [-1,1] x [-1,1]\nmesh = grid |> StdCoords()\n\nfig = Mke.Figure(size = (800, 400))\nviz(fig[1,1], grid)\nviz(fig[1,2], mesh)\nfig","category":"page"},{"location":"transforms/#Proj","page":"Transforms","title":"Proj","text":"","category":"section"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"Proj","category":"page"},{"location":"transforms/#Meshes.Proj","page":"Transforms","title":"Meshes.Proj","text":"Proj(CRS)\nProj(code)\n\nConvert the coordinates of geometry or domain to a given coordinate reference system CRS or EPSG/ESRI code.\n\nExamples\n\nProj(Polar)\nProj(WebMercator)\nProj(Mercator{WGS84Latest})\nProj(EPSG{3395})\nProj(ESRI{54017})\n\n\n\n\n\n","category":"type"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"# load coordinate reference system\nusing CoordRefSystems: Polar\n\n# triangle with Cartesian coordinates\ntriangle = Triangle((0, 0), (1, 0), (1, 1))\n\n# reproject to polar coordinates\ntriangle |> Proj(Polar)","category":"page"},{"location":"transforms/#LengthUnit","page":"Transforms","title":"LengthUnit","text":"","category":"section"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"LengthUnit","category":"page"},{"location":"transforms/#Meshes.LengthUnit","page":"Transforms","title":"Meshes.LengthUnit","text":"LengthUnit(unit)\n\nConvert the length unit of coordinates of a geometry or domain to unit.\n\nExamples\n\nLengthUnit(u\"cm\")\nLengthUnit(u\"km\")\n\n\n\n\n\n","category":"type"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"using Unitful: m, cm\n\n# convert meters to centimeters\nPoint(1m, 2m, 3m) |> LengthUnit(cm)","category":"page"},{"location":"transforms/#Shadow","page":"Transforms","title":"Shadow","text":"","category":"section"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"Shadow","category":"page"},{"location":"transforms/#Meshes.Shadow","page":"Transforms","title":"Meshes.Shadow","text":"Shadow(dims)\n\nProject the geometry or domain onto the given dims, producing a \"shadow\" of the original object.\n\nExamples\n\nShadow(:xy)\nShadow(\"xz\")\nShadow(1, 2)\nShadow((1, 3))\n\n\n\n\n\n","category":"type"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"ball = Ball((0, 0, 0), 1)\ndisk = ball |> Shadow(\"xy\")\n\n\nfig = Mke.Figure(size = (800, 400))\nviz(fig[1,1], ball)\nviz(fig[1,2], disk)\nfig","category":"page"},{"location":"transforms/#Crop","page":"Transforms","title":"Crop","text":"","category":"section"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"Crop","category":"page"},{"location":"transforms/#Meshes.Crop","page":"Transforms","title":"Meshes.Crop","text":"Crop(x=(xmin, xmax), y=(ymin, ymax), z=(zmin, zmax))\n\nRetain the domain geometries that intersect with x limits [xmax,xmax], y limits [ymax,ymax] and z limits [zmin,zmax] in length units (default to meters).\n\nExamples\n\nCrop(x=(2, 4))\nCrop(x=(1u\"km\", 3u\"km\"))\nCrop(y=(1.2, 1.8), z=(2.4, 3.0))\n\n\n\n\n\n","category":"type"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"grid = CartesianGrid(10, 10)\nsubgrid = grid |> Crop(x=(1.5, 6.5), y=(3.5, 8.5))\n\nfig = Mke.Figure(size = (800, 400))\nviz(fig[1,1], grid)\nviz(fig[1,2], subgrid)\nfig","category":"page"},{"location":"transforms/#Repair","page":"Transforms","title":"Repair","text":"","category":"section"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"Repair","category":"page"},{"location":"transforms/#Meshes.Repair","page":"Transforms","title":"Meshes.Repair","text":"Repair(K)\n\nPerform repairing operation with code K.\n\nAvailable operations\n\nK =  0: duplicated vertices and faces are removed\nK =  1: unused vertices are removed\nK =  2: non-manifold faces are removed\nK =  3: degenerate faces are removed\nK =  4: non-manifold vertices are removed\nK =  5: non-manifold vertices are split by threshold\nK =  6: close vertices are merged (given a radius)\nK =  7: faces are coherently oriented\nK =  8: zero-area ears are removed\nK =  9: rings of polygon are sorted\nK = 10: outer rings of polygon are expanded\nK = 11: rings of polygon are coherently oriented\nK = 12: degenerate rings of polygon are removed\n\nExamples\n\n# remove duplicates and degenerates\nmesh |> Repair(0) |> Repair(3)\n\n\n\n\n\n","category":"type"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"# mesh with unreferenced point\npoints = [(0, 0, 0), (0, 0, 1), (5, 5, 5), (0, 1, 0), (1, 0, 0)]\nconnec = connect.([(1, 2, 4), (1, 2, 5), (1, 4, 5), (2, 4, 5)])\nmesh   = SimpleMesh(points, connec)\n\nrmesh = mesh |> Repair(1)","category":"page"},{"location":"transforms/#Bridge","page":"Transforms","title":"Bridge","text":"","category":"section"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"Bridge","category":"page"},{"location":"transforms/#Meshes.Bridge","page":"Transforms","title":"Meshes.Bridge","text":"Bridge(δ=0)\n\nTransform polygon with holes into a single outer ring via bridges of given width δ as described in Held 1998.\n\nReferences\n\nHeld. 1998. FIST: Fast Industrial-Strength Triangulation of Polygons\n\n\n\n\n\n","category":"type"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"# polygon with two holes\nouter = [(0, 0), (1, 0), (1, 1), (0, 1)]\nhole1 = [(0.2, 0.2), (0.2, 0.4), (0.4, 0.4), (0.4, 0.2)]\nhole2 = [(0.6, 0.2), (0.6, 0.4), (0.8, 0.4), (0.8, 0.2)]\npoly = PolyArea([outer, hole1, hole2])\n\n# polygon with single outer ring\nbpoly = poly |> Bridge(0.01)\n\nfig = Mke.Figure(size = (800, 400))\nviz(fig[1,1], poly)\nviz(fig[1,2], bpoly)\nfig","category":"page"},{"location":"transforms/#Smoothing","page":"Transforms","title":"Smoothing","text":"","category":"section"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"LambdaMuSmoothing\nLaplaceSmoothing\nTaubinSmoothing","category":"page"},{"location":"transforms/#Meshes.LambdaMuSmoothing","page":"Transforms","title":"Meshes.LambdaMuSmoothing","text":"LambdaMuSmoothing(n, λ, μ)\n\nPerform n smoothing iterations with parameters λ and μ.\n\nSee also LaplaceSmoothing, TaubinSmoothing.\n\nReferences\n\nTaubin, G. 1995. Curve and Surface Smoothing without Shrinkage\n\n\n\n\n\n","category":"type"},{"location":"transforms/#Meshes.LaplaceSmoothing","page":"Transforms","title":"Meshes.LaplaceSmoothing","text":"LaplaceSmoothing(n, λ=0.5)\n\nPerform n iterations of Laplace smoothing with parameter λ.\n\nReferences\n\nSorkine, O. 2005. Laplacian Mesh Processing\n\n\n\n\n\n","category":"function"},{"location":"transforms/#Meshes.TaubinSmoothing","page":"Transforms","title":"Meshes.TaubinSmoothing","text":"TaubinSmoothing(n, λ=0.5)\n\nPerform n iterations of Taubin smoothing with parameter 0 < λ < 1.\n\nReferences\n\nTaubin, G. 1995. Curve and Surface Smoothing without Shrinkage\n\n\n\n\n\n","category":"function"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"using PlyIO\n\n# helper function to read *.ply files\nfunction readply(fname)\n  ply = load_ply(fname)\n  x = ply[\"vertex\"][\"x\"]\n  y = ply[\"vertex\"][\"y\"]\n  z = ply[\"vertex\"][\"z\"]\n  points = Point.(x, y, z)\n  connec = [connect(Tuple(c.+1)) for c in ply[\"face\"][\"vertex_indices\"]]\n  SimpleMesh(points, connec)\nend\n\n# download mesh from the web\nfile = download(\n  \"https://raw.githubusercontent.com/juliohm/JuliaCon2021/master/data/beethoven.ply\"\n)\n\n# read mesh from disk\nmesh = readply(file)\n\n# smooth mesh with 30 iterations\nsmesh = mesh |> TaubinSmoothing(30)\n\nfig = Mke.Figure(size = (800, 1200))\nviz(fig[1,1], mesh)\nviz(fig[2,1], smesh)\nfig","category":"page"},{"location":"algorithms/discretization/#Discretization","page":"Discretization","title":"Discretization","text":"","category":"section"},{"location":"algorithms/discretization/","page":"Discretization","title":"Discretization","text":"using Meshes # hide\nimport CairoMakie as Mke # hide","category":"page"},{"location":"algorithms/discretization/","page":"Discretization","title":"Discretization","text":"discretize\ndiscretizewithin\nsimplexify\nDiscretizationMethod","category":"page"},{"location":"algorithms/discretization/#Meshes.discretize","page":"Discretization","title":"Meshes.discretize","text":"discretize(geometry, [method])\n\nDiscretize geometry with discretization method.\n\nIf the method is ommitted, a default algorithm is used with a specific number of elements.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/discretization/#Meshes.discretizewithin","page":"Discretization","title":"Meshes.discretizewithin","text":"discretizewithin(boundary, method)\n\nDiscretize geometry within boundary with boundary discretization method.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/discretization/#Meshes.simplexify","page":"Discretization","title":"Meshes.simplexify","text":"simplexify(object)\n\nDiscretize object into simplices using an appropriate discretization method.\n\nNotes\n\nThis function is sometimes called \"triangulate\" when the object has parametric dimension 2.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/discretization/#Meshes.DiscretizationMethod","page":"Discretization","title":"Meshes.DiscretizationMethod","text":"DiscretizationMethod\n\nA method for discretizing geometries into meshes.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/discretization/#FanTriangulation","page":"Discretization","title":"FanTriangulation","text":"","category":"section"},{"location":"algorithms/discretization/","page":"Discretization","title":"Discretization","text":"FanTriangulation","category":"page"},{"location":"algorithms/discretization/#Meshes.FanTriangulation","page":"Discretization","title":"Meshes.FanTriangulation","text":"FanTriangulation()\n\nThe fan triangulation algorithm for convex polygons. See https://en.wikipedia.org/wiki/Fan_triangulation.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/discretization/","page":"Discretization","title":"Discretization","text":"hexagon = Hexagon((0.,0.), (1.,0.), (1.,1.),\n                  (0.75,1.5), (0.25,1.5), (0.,1.))\n\nmesh = discretize(hexagon, FanTriangulation())\n\nfig = Mke.Figure(size = (800, 400))\nviz(fig[1,1], hexagon)\nviz(fig[1,2], mesh, showsegments = true)\nfig","category":"page"},{"location":"algorithms/discretization/#DehnTriangulation","page":"Discretization","title":"DehnTriangulation","text":"","category":"section"},{"location":"algorithms/discretization/","page":"Discretization","title":"Discretization","text":"DehnTriangulation","category":"page"},{"location":"algorithms/discretization/#Meshes.DehnTriangulation","page":"Discretization","title":"Meshes.DehnTriangulation","text":"DehnTriangulation()\n\nMax Dehns' triangulation proved in 1899.\n\nThe algorithm is described in the first chapter of Devadoss & Rourke 2011, and is based on a theorem derived in 1899 by the German mathematician Max Dehn. See https://en.wikipedia.org/wiki/Two_ears_theorem.\n\nBecause the algorithm relies on recursion, it is mostly appropriate for polygons with small number of vertices.\n\nReferences\n\nDevadoss, S & Rourke, J. 2011. Discrete and computational geometry\n\n\n\n\n\n","category":"type"},{"location":"algorithms/discretization/","page":"Discretization","title":"Discretization","text":"# polygonal area\npolyarea = PolyArea([(0.22926679, 0.47329807), (0.23094065, 0.44913536), (0.2569517, 0.38217533),\n                     (0.3072999, 0.272418), (0.34814754, 0.18421611), (0.37949452, 0.11756973),\n                     (0.4013409, 0.07247882), (0.41368666, 0.048943404), (0.42597583, 0.031655528),\n                     (0.4382084, 0.0206152), (0.45038435, 0.015822414), (0.4625037, 0.017277176),\n                     (0.47175184, 0.02439156), (0.47812873, 0.03716557), (0.4816344, 0.055599205),\n                     (0.48226887, 0.07969247), (0.48172843, 0.10446181), (0.4800131, 0.12990724),\n                     (0.47712287, 0.15602873), (0.47305775, 0.18282633), (0.47093934, 0.20558843),\n                     (0.47076762, 0.22431506), (0.47254258, 0.23900622), (0.47626427, 0.24966191),\n                     (0.47768936, 0.25845313), (0.47681788, 0.26537988), (0.4736498, 0.27044216),\n                     (0.46818516, 0.27363995), (0.4613889, 0.27232954), (0.45326096, 0.2665109),\n                     (0.44380143, 0.256184), (0.43301025, 0.24134888), (0.4246466, 0.22978415),\n                     (0.41871038, 0.22148979), (0.4152017, 0.21646582), (0.4141205, 0.21471222),\n                     (0.41227448, 0.21589448), (0.40966362, 0.22001258), (0.40628797, 0.22706655),\n                     (0.40214747, 0.23705636), (0.40200475, 0.24653101), (0.40585983, 0.25549048),\n                     (0.41371268, 0.2639348), (0.4255633, 0.2718639), (0.4378565, 0.28495985),\n                     (0.4505922, 0.30322257), (0.46377045, 0.32665208), (0.47739124, 0.35524836),\n                     (0.5046394, 0.36442512), (0.5455148, 0.35418236), (0.60001767, 0.32452005),\n                     (0.66814786, 0.27543822), (0.7186763, 0.24664374), (0.75160307, 0.23813659),\n                     (0.76692814, 0.2499168), (0.7646515, 0.28198436), (0.7769703, 0.29925033),\n                     (0.8038847, 0.3017147), (0.84539455, 0.28937748), (0.9015, 0.26223865),\n                     (0.94408435, 0.24899776), (0.9731477, 0.24965483), (0.98869, 0.26420987),\n                     (0.9907113, 0.29266283), (0.9849871, 0.31338844), (0.97151726, 0.32638666),\n                     (0.950302, 0.3316575), (0.9213412, 0.32920095), (0.8798396, 0.34078467),\n                     (0.8257972, 0.36640862), (0.7592141, 0.40607283), (0.6800901, 0.4597773),\n                     (0.6450007, 0.49104902), (0.6539457, 0.49988794), (0.7069251, 0.48629412),\n                     (0.803939, 0.45026752), (0.877913, 0.4226481), (0.9288472, 0.40343583),\n                     (0.9567415, 0.39263073), (0.961596, 0.39023277), (0.9419039, 0.40523484),\n                     (0.89766514, 0.43763688), (0.8288798, 0.48743892), (0.7355478, 0.55464095),\n                     (0.6655121, 0.60063523), (0.6187727, 0.6254217), (0.5953296, 0.62900037),\n                     (0.5951828, 0.6113712), (0.57516366, 0.60261106), (0.53527224, 0.6027198),\n                     (0.4755085, 0.6116975), (0.3958725, 0.6295441), (0.33913234, 0.6398651),\n                     (0.30528808, 0.6426605), (0.2943397, 0.6379303), (0.30628717, 0.6256744),\n                     (0.32149008, 0.6093727), (0.33994842, 0.5890249), (0.36166218, 0.5646312),\n                     (0.38663134, 0.5361916), (0.3919681, 0.520893), (0.3776725, 0.5187355),\n                     (0.34374446, 0.52971905), (0.29018405, 0.5538437), (0.25439468, 0.5678829),\n                     (0.2363764, 0.5718367), (0.23612918, 0.56570506), (0.25365302, 0.549488),\n                     (0.2733971, 0.5246488), (0.29536137, 0.49118724), (0.3195459, 0.4491035),\n                     (0.34595063, 0.39839754), (0.3647463, 0.3590396), (0.37593287, 0.33102974),\n                     (0.37951034, 0.31436795), (0.37547874, 0.30905423), (0.36070493, 0.3204269),\n                     (0.33518887, 0.348486), (0.29893062, 0.3932315), (0.25193012, 0.45466346)])\n\nmesh = discretize(polyarea, DehnTriangulation())\n\nfig = Mke.Figure(size = (800, 400))\nviz(fig[1,1], polyarea)\nviz(fig[1,2], mesh, showsegments = true)\nfig","category":"page"},{"location":"algorithms/discretization/#HeldTriangulation","page":"Discretization","title":"HeldTriangulation","text":"","category":"section"},{"location":"algorithms/discretization/","page":"Discretization","title":"Discretization","text":"HeldTriangulation","category":"page"},{"location":"algorithms/discretization/#Meshes.HeldTriangulation","page":"Discretization","title":"Meshes.HeldTriangulation","text":"HeldTriangulation([rng]; shuffle=true)\n\nFast Industrial-Strength Triangulation (FIST) of polygons.\n\nThis triangulation method is the method behind the famous Mapbox's Earcut library. It is based on a ear clipping algorithm adapted for complex n-gons with holes. It has O(n²) time complexity where n is the number of vertices. In practice it is very efficient due to heuristics implemented in the algorithm.\n\nThe option shuffle is used to shuffle the order in which ears are clipped. It improves the quality of the triangles, which can be very sliver otherwise. Optionally, specify the random number generator rng.\n\nReferences\n\nHeld, M. 1998. FIST: Fast Industrial-Strength Triangulation of Polygons\nEder et al. 2018. Parallelized ear clipping for the triangulation and constrained Delaunay triangulation of polygons\n\n\n\n\n\n","category":"type"},{"location":"algorithms/discretization/","page":"Discretization","title":"Discretization","text":"mesh = discretize(polyarea, HeldTriangulation())\n\nfig = Mke.Figure(size = (800, 400))\nviz(fig[1,1], polyarea)\nviz(fig[1,2], mesh, showsegments = true)\nfig","category":"page"},{"location":"algorithms/discretization/#DelaunayTriangulation","page":"Discretization","title":"DelaunayTriangulation","text":"","category":"section"},{"location":"algorithms/discretization/","page":"Discretization","title":"Discretization","text":"DelaunayTriangulation","category":"page"},{"location":"algorithms/discretization/#Meshes.DelaunayTriangulation","page":"Discretization","title":"Meshes.DelaunayTriangulation","text":"DelaunayTriangulation()\n\nConstrained Delaunay triangulation of polygons. Optionally, specify the random number generator rng.\n\nReferences\n\nCheng et al. 2012. Delaunay Mesh Generation\n\nNotes\n\nWraps DelaunayTriangulation.jl. For any internal errors, file an issue at  DelaunayTriangulation.jl\n\n\n\n\n\n","category":"type"},{"location":"algorithms/discretization/","page":"Discretization","title":"Discretization","text":"mesh = discretize(polyarea, DelaunayTriangulation())\n\nfig = Mke.Figure(size = (800, 400))\nviz(fig[1,1], polyarea)\nviz(fig[1,2], mesh, showsegments = true)\nfig","category":"page"},{"location":"algorithms/discretization/","page":"Discretization","title":"Discretization","text":"As can be seen in the following example, all discretization methods for Polygon automatically work in the presence of holes:","category":"page"},{"location":"algorithms/discretization/","page":"Discretization","title":"Discretization","text":"outer = [(0.18142937, 0.54681134), (0.38282228, 0.107781954), (0.43220532, 0.013640274),\n         (0.48068276, 0.019459315), (0.48322055, 0.11583236), (0.46696007, 0.2230227),\n         (0.48184678, 0.2656454), (0.45998818, 0.2784367), (0.4168235, 0.2190962),\n         (0.4124987, 0.21208182), (0.39593673, 0.2520411), (0.44333926, 0.28375763),\n         (0.4978224, 0.3981428), (0.7703431, 0.20181546), (0.7612364, 0.33008572),\n         (0.9856581, 0.2215304), (0.99374324, 0.3353423), (0.9688778, 0.38663587),\n         (0.59554976, 0.655444), (0.59496254, 0.58492756), (0.27641845, 0.656314),\n         (0.3242084, 0.6072907), (0.42408508, 0.49353212), (0.20984341, 0.59003067)]\n\ninners = [[(0.87789994, 0.32551613), (0.5614043, 0.540334), (0.9494598, 0.39622766)],\n          [(0.2799388, 0.52516246), (0.38555774, 0.32233855), (0.36943135, 0.30108362)]]\n\npolyarea = PolyArea([outer, inners...])\n\nmesh = discretize(polyarea, DelaunayTriangulation())\n\nfig = Mke.Figure(size = (800, 400))\nviz(fig[1,1], polyarea)\nviz(fig[1,2], mesh, showsegments = true)\nfig","category":"page"},{"location":"algorithms/discretization/#RegularDiscretization","page":"Discretization","title":"RegularDiscretization","text":"","category":"section"},{"location":"algorithms/discretization/","page":"Discretization","title":"Discretization","text":"RegularDiscretization","category":"page"},{"location":"algorithms/discretization/#Meshes.RegularDiscretization","page":"Discretization","title":"Meshes.RegularDiscretization","text":"RegularDiscretization(n1, n2, ..., np)\n\nA method to discretize primitive geometries with n1×n2×...×np elements sampled regularly along each parametric dimensions. The adequate number of points is calculated for each type of geometry and passed to RegularSampling.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/discretization/","page":"Discretization","title":"Discretization","text":"sphere = Sphere((0.,0.,0.), 1.)\n\nmesh = discretize(sphere, RegularDiscretization(10,10))\n\nviz(mesh, showsegments = true)","category":"page"},{"location":"algorithms/discretization/#ManualDiscretization","page":"Discretization","title":"ManualDiscretization","text":"","category":"section"},{"location":"algorithms/discretization/","page":"Discretization","title":"Discretization","text":"ManualDiscretization","category":"page"},{"location":"algorithms/discretization/#Meshes.ManualDiscretization","page":"Discretization","title":"Meshes.ManualDiscretization","text":"ManualDiscretization()\n\nDiscretize geometries manually using indices of vertices.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/discretization/","page":"Discretization","title":"Discretization","text":"box = Box((0., 0., 0.), (1., 1., 1.))\n\nmesh = discretize(box, ManualDiscretization())\n\nviz(mesh, colors = 1:nelements(mesh))","category":"page"},{"location":"contributing/guidelines/#Guidelines","page":"Guidelines","title":"Guidelines","text":"","category":"section"},{"location":"contributing/guidelines/","page":"Guidelines","title":"Guidelines","text":"First off, thank you for considering contributing to Meshes.jl. Below are a few suggestions to speed up the collaboration process:","category":"page"},{"location":"contributing/guidelines/","page":"Guidelines","title":"Guidelines","text":"Please be polite, we are here to help and learn from each other.\nTry to explain your contribution with simple language.\nReferences to textbooks and papers are always welcome.\nFollow the coding standards in the source.","category":"page"},{"location":"contributing/guidelines/#Reporting-issues","page":"Guidelines","title":"Reporting issues","text":"","category":"section"},{"location":"contributing/guidelines/","page":"Guidelines","title":"Guidelines","text":"If you are experiencing issues or have discovered a bug, please report it on GitHub. To make the resolution process easier, please include the version of Julia and Meshes.jl in your writeup. These can be found with two commands:","category":"page"},{"location":"contributing/guidelines/","page":"Guidelines","title":"Guidelines","text":"julia> versioninfo()\njulia> using Pkg; Pkg.status()","category":"page"},{"location":"contributing/guidelines/#Feature-requests","page":"Guidelines","title":"Feature requests","text":"","category":"section"},{"location":"contributing/guidelines/","page":"Guidelines","title":"Guidelines","text":"If you have suggestions of improvement or algorithms that you would like to see implemented in Meshes.jl, please open an issue on GitHub. Suggestions as well as feature requests are very welcome.","category":"page"},{"location":"contributing/guidelines/#Code-contribution","page":"Guidelines","title":"Code contribution","text":"","category":"section"},{"location":"contributing/guidelines/","page":"Guidelines","title":"Guidelines","text":"If you have code that you would like to contribute to Meshes.jl, that is awesome! Please open an issue before you create the pull request on GitHub so that we make sure your idea is aligned with our goals for the project.","category":"page"},{"location":"contributing/guidelines/","page":"Guidelines","title":"Guidelines","text":"After your idea is discussed and revised by maintainers, please get the development version of the project by typing the following in the package manager:","category":"page"},{"location":"contributing/guidelines/","page":"Guidelines","title":"Guidelines","text":"] activate @dev","category":"page"},{"location":"contributing/guidelines/","page":"Guidelines","title":"Guidelines","text":"This will create a fresh environment called @dev where you can play with the project components without compromising your normal user environment.","category":"page"},{"location":"contributing/guidelines/","page":"Guidelines","title":"Guidelines","text":"] dev Meshes","category":"page"},{"location":"contributing/guidelines/","page":"Guidelines","title":"Guidelines","text":"This will clone all the project components in your ~/.julia folder so that you can modify it and submit a pull request on GitHub later. Don't hesitate to ask questions. We are looking forward to your contributions.","category":"page"},{"location":"algorithms/neighborsearch/#Neighbor-search","page":"Neighbor search","title":"Neighbor search","text":"","category":"section"},{"location":"algorithms/neighborsearch/","page":"Neighbor search","title":"Neighbor search","text":"using Meshes # hide\nimport CairoMakie as Mke # hide","category":"page"},{"location":"algorithms/neighborsearch/","page":"Neighbor search","title":"Neighbor search","text":"It is often useful to search neighbor elements in a domain given a point of reference. This can be performed with search methods:","category":"page"},{"location":"algorithms/neighborsearch/","page":"Neighbor search","title":"Neighbor search","text":"NeighborSearchMethod\nsearch\nsearch!\nsearchdists\nsearchdists!","category":"page"},{"location":"algorithms/neighborsearch/#Meshes.NeighborSearchMethod","page":"Neighbor search","title":"Meshes.NeighborSearchMethod","text":"NeighborSearchMethod\n\nA method for searching neighbors given a reference point.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/neighborsearch/#Meshes.search","page":"Neighbor search","title":"Meshes.search","text":"search(pₒ, method, mask=nothing)\n\nReturn neighbors of point pₒ using method. Optionally, specify a mask for all indices of the domain.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/neighborsearch/#Meshes.search!","page":"Neighbor search","title":"Meshes.search!","text":"search!(neighbors, pₒ, method; mask=nothing)\n\nUpdate neighbors of point pₒ using method and return number of neighbors found. Optionally, specify a mask for all indices of the domain.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/neighborsearch/#Meshes.searchdists","page":"Neighbor search","title":"Meshes.searchdists","text":"searchdists(pₒ, method, mask=nothing)\n\nReturn neighbors and distances of point pₒ using method. Optionally, specify a mask for all indices of the domain.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/neighborsearch/#Meshes.searchdists!","page":"Neighbor search","title":"Meshes.searchdists!","text":"searchdists!(neighbors, distances, pₒ, method; mask=nothing)\n\nUpdate neighbors and distances of point pₒ using method and return number of neighbors found. Optionally, specify a mask for all indices of the domain.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/neighborsearch/","page":"Neighbor search","title":"Neighbor search","text":"Search methods are constructed with various types of parameters. One may be interested in k-nearest neighbors, or interested in neighbors within a certain Neighborhood:","category":"page"},{"location":"algorithms/neighborsearch/","page":"Neighbor search","title":"Neighbor search","text":"Neighborhood\nMetricBall","category":"page"},{"location":"algorithms/neighborsearch/#Meshes.Neighborhood","page":"Neighbor search","title":"Meshes.Neighborhood","text":"Neighborhood\n\nA neighborhood is a geometry that is not attached to any specific point in space, and is free to slide over a domain of interest.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/neighborsearch/#Meshes.MetricBall","page":"Neighbor search","title":"Meshes.MetricBall","text":"MetricBall(radii, rotation=nothing)\nMetricBall(radius, metric=Euclidean())\n\nA metric ball is a neighborhood that can be expressed in terms of a metric and a set of radii. The two main examples are the Euclidean ball an the Mahalanobis (ellipsoid) ball.\n\nWhen multiple radii are provided, they can be rotated by a rotation specification from the Rotations.jl package. Alternatively, a metric from the Distances.jl package can be specified together with a single radius.\n\nExamples\n\nN-dimensional Euclidean ball with radius 1.0:\n\njulia> euclidean = MetricBall(1.0)\n\nAxis-aligned 3D ellipsoid with radii (3.0, 2.0, 1.0):\n\njulia> mahalanobis = MetricBall((3.0, 2.0, 1.0))\n\n\n\n\n\n","category":"type"},{"location":"algorithms/neighborsearch/","page":"Neighbor search","title":"Neighbor search","text":"The following example demonstrates neighbor search with the KNearestSearch method:","category":"page"},{"location":"algorithms/neighborsearch/","page":"Neighbor search","title":"Neighbor search","text":"grid = CartesianGrid(10, 10)\n\n# 4-nearest neighbors\nsearcher = KNearestSearch(grid, 4)\n\ninds = search(Point(5.0, 5.0), searcher)","category":"page"},{"location":"algorithms/neighborsearch/","page":"Neighbor search","title":"Neighbor search","text":"The function search returns the indices of the elements in the domain that are neighbors of the point. The elements are:","category":"page"},{"location":"algorithms/neighborsearch/","page":"Neighbor search","title":"Neighbor search","text":"grid[inds]","category":"page"},{"location":"algorithms/neighborsearch/","page":"Neighbor search","title":"Neighbor search","text":"Alternatively, the function searchdists also returns the distances to the (centroids) of the elements:","category":"page"},{"location":"algorithms/neighborsearch/","page":"Neighbor search","title":"Neighbor search","text":"inds, dists = searchdists(Point(5.0, 5.0), searcher)\n\ndists","category":"page"},{"location":"algorithms/neighborsearch/","page":"Neighbor search","title":"Neighbor search","text":"Finally, the functions search! and searchdists! can be used in hot loops to avoid unnecessary memory allocations.","category":"page"},{"location":"algorithms/neighborsearch/#BallSearch","page":"Neighbor search","title":"BallSearch","text":"","category":"section"},{"location":"algorithms/neighborsearch/","page":"Neighbor search","title":"Neighbor search","text":"BallSearch","category":"page"},{"location":"algorithms/neighborsearch/#Meshes.BallSearch","page":"Neighbor search","title":"Meshes.BallSearch","text":"BallSearch(domain, ball)\n\nA method for searching neighbors in domain inside ball.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/neighborsearch/#KNearestSearch","page":"Neighbor search","title":"KNearestSearch","text":"","category":"section"},{"location":"algorithms/neighborsearch/","page":"Neighbor search","title":"Neighbor search","text":"KNearestSearch","category":"page"},{"location":"algorithms/neighborsearch/#Meshes.KNearestSearch","page":"Neighbor search","title":"Meshes.KNearestSearch","text":"KNearestSearch(domain, k; metric=Euclidean())\n\nA method for searching k nearest neighbors in domain according to metric.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/neighborsearch/#KBallSearch","page":"Neighbor search","title":"KBallSearch","text":"","category":"section"},{"location":"algorithms/neighborsearch/","page":"Neighbor search","title":"Neighbor search","text":"KBallSearch","category":"page"},{"location":"algorithms/neighborsearch/#Meshes.KBallSearch","page":"Neighbor search","title":"Meshes.KBallSearch","text":"KBallSearch(domain, k, ball)\n\nA method that searches k nearest neighbors and then filters these neighbors using a norm ball.\n\n\n\n\n\n","category":"type"},{"location":"rand/#Random","page":"Random","title":"Random","text":"","category":"section"},{"location":"rand/","page":"Random","title":"Random","text":"using Meshes # hide\nusing Random # hide\nusing CoordRefSystems # hide","category":"page"},{"location":"rand/","page":"Random","title":"Random","text":"rand(::Type{<:Geometry})\nrand(::Type{<:Geometry}, ::Int)","category":"page"},{"location":"rand/#Base.rand-Tuple{Type{<:Geometry}}","page":"Random","title":"Base.rand","text":"rand([rng], G, crs=Cartesian3D)\n\nGenerate a random geometry of type G with CRS crs, optionally passing a random number generator rng.\n\nExamples\n\nrand(Point)\nrand(Triangle)\nrand(Point, crs=Cartesian2D)\nrand(Triangle, crs=LatLon)\n\n\n\n\n\n","category":"method"},{"location":"rand/#Base.rand-Tuple{Type{<:Geometry}, Int64}","page":"Random","title":"Base.rand","text":"rand([rng], G, n, crs=Cartesian3D)\n\nGenerate a vector of n random geometries of type G with CRS crs, optionally passing a random number generator rng.\n\nExamples\n\nrand(Point, 10)\nrand(Triangle, 10)\nrand(Point, 10, crs=Cartesian2D)\nrand(Triangle, 10, crs=LatLon)\n\n\n\n\n\n","category":"method"},{"location":"rand/","page":"Random","title":"Random","text":"Random geometries can be generated using the rand function:","category":"page"},{"location":"rand/","page":"Random","title":"Random","text":"rand(Point)","category":"page"},{"location":"rand/","page":"Random","title":"Random","text":"By default, the rand function uses the Cartesian3D CRS (Coordinate Reference System). It's possible to change the CRS using the crs keyword argument:","category":"page"},{"location":"rand/","page":"Random","title":"Random","text":"rand(Point, crs=Cartesian2D)","category":"page"},{"location":"rand/","page":"Random","title":"Random","text":"A vector of geometries can be generated by passing the number of elements as the second argument:","category":"page"},{"location":"rand/","page":"Random","title":"Random","text":"rand(Segment, 5, crs=LatLon)","category":"page"},{"location":"rand/","page":"Random","title":"Random","text":"For reproducibility purposes, a random number generator can be passed as the first argument in both methods:","category":"page"},{"location":"rand/","page":"Random","title":"Random","text":"rng = MersenneTwister(123)\nrand(rng, Triangle)","category":"page"},{"location":"rand/","page":"Random","title":"Random","text":"rand(rng, Triangle, 5)","category":"page"},{"location":"algorithms/intersection/#Intersection","page":"Intersection","title":"Intersection","text":"","category":"section"},{"location":"algorithms/intersection/","page":"Intersection","title":"Intersection","text":"Intersections are implemented for various geometries and domains with the ∩ (\\cap) operator:","category":"page"},{"location":"algorithms/intersection/","page":"Intersection","title":"Intersection","text":"using Meshes\n\ns1 = Segment((0.0,0.0), (1.0,0.0))\ns2 = Segment((0.5,0.0), (2.0,0.0))\n\ns1 ∩ s2","category":"page"},{"location":"algorithms/intersection/","page":"Intersection","title":"Intersection","text":"First, the intersection function computes the Intersection object, which holds the IntersectionType besides the actual geometry:","category":"page"},{"location":"algorithms/intersection/","page":"Intersection","title":"Intersection","text":"I = intersection(s1, s2)","category":"page"},{"location":"algorithms/intersection/","page":"Intersection","title":"Intersection","text":"This object supports two methods type and get to retrieve the underlying information:","category":"page"},{"location":"algorithms/intersection/","page":"Intersection","title":"Intersection","text":"type(I)","category":"page"},{"location":"algorithms/intersection/","page":"Intersection","title":"Intersection","text":"get(I)","category":"page"},{"location":"algorithms/intersection/","page":"Intersection","title":"Intersection","text":"For performance-sensitive code, it is recommended to use the intersection method with three arguments, including a function to reduce the number of output types.","category":"page"},{"location":"algorithms/intersection/","page":"Intersection","title":"Intersection","text":"In the example below, we use the do syntax to restrict our attention to a subset of intersection types and to make the return type and Int value in all cases:","category":"page"},{"location":"algorithms/intersection/","page":"Intersection","title":"Intersection","text":"intersection(s1, s2) do I\n  if type(I) == Crossing\n    return 1\n  elseif type(I) == Overlapping\n    return 2\n  else\n    return 3\n  end\nend","category":"page"},{"location":"algorithms/intersection/","page":"Intersection","title":"Intersection","text":"IntersectionType\nIntersection\nintersection\nintersect(::Geometry, ::Geometry)","category":"page"},{"location":"algorithms/intersection/#Meshes.IntersectionType","page":"Intersection","title":"Meshes.IntersectionType","text":"IntersectionType\n\nThe different types of intersection that may occur between geometries. Type IntersectionType in a Julia session to see the full list.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/intersection/#Meshes.Intersection","page":"Intersection","title":"Meshes.Intersection","text":"Intersection{G}\n\nAn intersection between geometries holding a geometry of type G.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/intersection/#Meshes.intersection","page":"Intersection","title":"Meshes.intersection","text":"intersection([f], g₁, g₂)\n\nCompute the intersection of two geometries or domains g₁ and g₂ and apply function f to it. Default function is identity.\n\nExamples\n\nintersection(g₁, g₂) do I\n  if I isa CrossingLines\n    # do something\n  else\n    # do nothing\n  end\nend\n\nNotes\n\nWhen a custom function f is used that reduces the number of return types, Julia is able to optimize the branches of the code and generate specialized code. This is not the case when f === identity.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/intersection/#Base.intersect-Tuple{Geometry, Geometry}","page":"Intersection","title":"Base.intersect","text":"g₁ ∩ g₂\n\nReturn the intersection of two geometries or domains g₁ and g₂ as a new (multi-)geometry.\n\n\n\n\n\n","category":"method"},{"location":"geometries/primitives/#Primitives","page":"Primitives","title":"Primitives","text":"","category":"section"},{"location":"geometries/primitives/","page":"Primitives","title":"Primitives","text":"using Meshes # hide\nimport CairoMakie as Mke # hide","category":"page"},{"location":"geometries/primitives/#Abstract","page":"Primitives","title":"Abstract","text":"","category":"section"},{"location":"geometries/primitives/","page":"Primitives","title":"Primitives","text":"Primitive","category":"page"},{"location":"geometries/primitives/#Meshes.Primitive","page":"Primitives","title":"Meshes.Primitive","text":"Primitive{M,CRS}\n\nWe say that a geometry is a primitive when it can be expressed as a single entity with no parts (a.k.a. atomic). For example, a sphere is a primitive described in terms of a mathematical expression involving a metric and a radius. See https://en.wikipedia.org/wiki/Geometric_primitive.\n\n\n\n\n\n","category":"type"},{"location":"geometries/primitives/#Concrete","page":"Primitives","title":"Concrete","text":"","category":"section"},{"location":"geometries/primitives/#Point","page":"Primitives","title":"Point","text":"","category":"section"},{"location":"geometries/primitives/","page":"Primitives","title":"Primitives","text":"Point","category":"page"},{"location":"geometries/primitives/#Meshes.Point","page":"Primitives","title":"Meshes.Point","text":"Point(x₁, x₂, ..., xₙ)\nPoint((x₁, x₂, ..., xₙ))\n\nA point in Dim-dimensional space with coordinates in length units (default to meters).\n\nThe coordinates of the point are given with respect to the canonical Euclidean basis, and integer coordinates are converted to float.\n\nExamples\n\n# 2D points\nPoint(1.0, 2.0) # add default units\nPoint(1.0m, 2.0m) # double precision as expected\nPoint(1f0km, 2f0km) # single precision as expected\nPoint(1m, 2m) # integer is converted to float by design\n\n# 3D points\nPoint(1.0, 2.0, 3.0) # add default units\nPoint(1.0m, 2.0m, 3.0m) # double precision as expected\nPoint(1f0km, 2f0km, 3f0km) # single precision as expected\nPoint(1m, 2m, 3m) # integer is converted to float by design\n\nNotes\n\nInteger coordinates are not supported because most geometric processing algorithms assume a continuous space. The conversion to float avoids InexactError and other unexpected results.\n\n\n\n\n\n","category":"type"},{"location":"geometries/primitives/","page":"Primitives","title":"Primitives","text":"rand(Point, 100) |> viz","category":"page"},{"location":"geometries/primitives/","page":"Primitives","title":"Primitives","text":"to(::Point)\n-(::Point, ::Point)\n+(::Point, ::Vec)\n-(::Point, ::Vec)","category":"page"},{"location":"geometries/primitives/#Meshes.to-Tuple{Point}","page":"Primitives","title":"Meshes.to","text":"to(point)\n\nReturn the vector from the origin to the point.\n\n\n\n\n\n","category":"method"},{"location":"geometries/primitives/#Base.:--Tuple{Point, Point}","page":"Primitives","title":"Base.:-","text":"-(A::Point, B::Point)\n\nReturn the Vec associated with the direction from point B to point A.\n\n\n\n\n\n","category":"method"},{"location":"geometries/primitives/#Base.:+-Tuple{Point, Vec}","page":"Primitives","title":"Base.:+","text":"+(A::Point, v::Vec)\n+(v::Vec, A::Point)\n\nReturn the point at the end of the vector v placed at a reference (or start) point A.\n\n\n\n\n\n","category":"method"},{"location":"geometries/primitives/#Base.:--Tuple{Point, Vec}","page":"Primitives","title":"Base.:-","text":"-(A::Point, v::Vec)\n-(v::Vec, A::Point)\n\nReturn the point at the end of the vector -v placed at a reference (or start) point A.\n\n\n\n\n\n","category":"method"},{"location":"geometries/primitives/#Ray","page":"Primitives","title":"Ray","text":"","category":"section"},{"location":"geometries/primitives/","page":"Primitives","title":"Primitives","text":"Ray","category":"page"},{"location":"geometries/primitives/#Meshes.Ray","page":"Primitives","title":"Meshes.Ray","text":"Ray(p, v)\n\nA ray originating at point p, pointed in direction v. It can be called as r(t) with t > 0 to cast it at p + t * v.\n\n\n\n\n\n","category":"type"},{"location":"geometries/primitives/#Line","page":"Primitives","title":"Line","text":"","category":"section"},{"location":"geometries/primitives/","page":"Primitives","title":"Primitives","text":"Line","category":"page"},{"location":"geometries/primitives/#Meshes.Line","page":"Primitives","title":"Meshes.Line","text":"Line(a, b)\n\nA line passing through points a and b.\n\nSee also Segment.\n\n\n\n\n\n","category":"type"},{"location":"geometries/primitives/#BezierCurve","page":"Primitives","title":"BezierCurve","text":"","category":"section"},{"location":"geometries/primitives/","page":"Primitives","title":"Primitives","text":"BezierCurve","category":"page"},{"location":"geometries/primitives/#Meshes.BezierCurve","page":"Primitives","title":"Meshes.BezierCurve","text":"BezierCurve(points)\n\nA recursive Bézier curve with control points points. See https://en.wikipedia.org/wiki/Bézier_curve. A point on the curve b can be evaluated by calling b(t) with t between 0 and 1. The evaluation method defaults to DeCasteljau's algorithm for accurate evaluation. Horner's method, faster with a large number of points but less precise, can be used via b(t, Horner()).\n\nExamples\n\nBezierCurve([(0.,0.),(1.,-1.)])\n\n\n\n\n\n","category":"type"},{"location":"geometries/primitives/","page":"Primitives","title":"Primitives","text":"BezierCurve((0.,0.), (1.,0.), (1.,1.)) |> viz","category":"page"},{"location":"geometries/primitives/#Plane","page":"Primitives","title":"Plane","text":"","category":"section"},{"location":"geometries/primitives/","page":"Primitives","title":"Primitives","text":"Plane","category":"page"},{"location":"geometries/primitives/#Meshes.Plane","page":"Primitives","title":"Meshes.Plane","text":"Plane(p, u, v)\n\nA plane embedded in R³ passing through point p, defined by non-parallel vectors u and v.\n\nPlane(p, n)\n\nAlternatively specify point p and a given normal vector n to the plane.\n\n\n\n\n\n","category":"type"},{"location":"geometries/primitives/#Box","page":"Primitives","title":"Box","text":"","category":"section"},{"location":"geometries/primitives/","page":"Primitives","title":"Primitives","text":"Box","category":"page"},{"location":"geometries/primitives/#Meshes.Box","page":"Primitives","title":"Meshes.Box","text":"Box(min, max)\n\nA (geodesic) box with min and max points on a given manifold.\n\nExamples\n\nConstruct a 3D box using points with Cartesian coordinates:\n\nBox((0, 0, 0), (1, 1, 1))\n\nLikewise, construct a 2D box on the plane:\n\nBox((0, 0), (1, 1))\n\nConstruct a geodesic box on the ellipsoid:\n\nBox(Point(LatLon(0, 0)), Point(LatLon(1, 1)))\n\n\n\n\n\n","category":"type"},{"location":"geometries/primitives/","page":"Primitives","title":"Primitives","text":"Box((0.,0.,0.), (1.,1.,1.)) |> viz","category":"page"},{"location":"geometries/primitives/#Ball/Sphere","page":"Primitives","title":"Ball/Sphere","text":"","category":"section"},{"location":"geometries/primitives/","page":"Primitives","title":"Primitives","text":"Ball\nSphere","category":"page"},{"location":"geometries/primitives/#Meshes.Ball","page":"Primitives","title":"Meshes.Ball","text":"Ball(center, radius)\n\nA ball with center and radius.\n\nSee also Sphere.\n\n\n\n\n\n","category":"type"},{"location":"geometries/primitives/#Meshes.Sphere","page":"Primitives","title":"Meshes.Sphere","text":"Sphere(center, radius)\n\nA sphere with center and radius.\n\nSee also Ball.\n\n\n\n\n\n","category":"type"},{"location":"geometries/primitives/","page":"Primitives","title":"Primitives","text":"Ball((0.,0.,0.), 1.) |> viz","category":"page"},{"location":"geometries/primitives/#Ellipsoid","page":"Primitives","title":"Ellipsoid","text":"","category":"section"},{"location":"geometries/primitives/","page":"Primitives","title":"Primitives","text":"Ellipsoid","category":"page"},{"location":"geometries/primitives/#Meshes.Ellipsoid","page":"Primitives","title":"Meshes.Ellipsoid","text":"Ellipsoid(radii, center=(0, 0, 0), rotation=I)\n\nA 3D ellipsoid with given radii, center and rotation.\n\n\n\n\n\n","category":"type"},{"location":"geometries/primitives/","page":"Primitives","title":"Primitives","text":"Ellipsoid((3., 2., 1.)) |> viz","category":"page"},{"location":"geometries/primitives/#Disk/Circle","page":"Primitives","title":"Disk/Circle","text":"","category":"section"},{"location":"geometries/primitives/","page":"Primitives","title":"Primitives","text":"Disk\nCircle","category":"page"},{"location":"geometries/primitives/#Meshes.Disk","page":"Primitives","title":"Meshes.Disk","text":"Disk(plane, radius)\n\nA disk embedded in 3-dimensional space on a given plane with given radius.\n\nSee also Circle.\n\n\n\n\n\n","category":"type"},{"location":"geometries/primitives/#Meshes.Circle","page":"Primitives","title":"Meshes.Circle","text":"Circle(plane, radius)\n\nA circle embedded in 3-dimensional space on a given plane with given radius.\n\nSee also Disk.\n\n\n\n\n\n","category":"type"},{"location":"geometries/primitives/#Cylinder/CylinderSurface","page":"Primitives","title":"Cylinder/CylinderSurface","text":"","category":"section"},{"location":"geometries/primitives/","page":"Primitives","title":"Primitives","text":"Cylinder\nCylinderSurface","category":"page"},{"location":"geometries/primitives/#Meshes.Cylinder","page":"Primitives","title":"Meshes.Cylinder","text":"Cylinder(bottom, top, radius)\n\nA solid circular cylinder embedded in R³ with given radius, delimited by bottom and top planes.\n\nCylinder(start, finish, radius)\n\nAlternatively, construct a right circular cylinder with given radius along the segment with start and finish end points.\n\nCylinder(start, finish)\n\nOr construct a right circular cylinder with unit radius along the segment with start and finish end points.\n\nCylinder(radius)\n\nFinally, construct a right vertical circular cylinder with given radius.\n\nSee https://en.wikipedia.org/wiki/Cylinder. \n\n\n\n\n\n","category":"type"},{"location":"geometries/primitives/#Meshes.CylinderSurface","page":"Primitives","title":"Meshes.CylinderSurface","text":"CylinderSurface(bottom, top, radius)\n\nA circular cylinder surface embedded in R³ with given radius, delimited by bottom and top planes.\n\nCylinderSurface(start, finish, radius)\n\nAlternatively, construct a right circular cylinder surface with given radius along the segment with start and finish end points.\n\nCylinderSurface(start, finish)\n\nOr construct a right circular cylinder surface with unit radius along the segment with start and finish end points.\n\nCylinderSurface(radius)\n\nFinally, construct a right vertical circular cylinder surface with given radius.\n\nSee https://en.wikipedia.org/wiki/Cylinder. \n\n\n\n\n\n","category":"type"},{"location":"geometries/primitives/","page":"Primitives","title":"Primitives","text":"Cylinder(1.0) |> viz","category":"page"},{"location":"geometries/primitives/#Cone/ConeSurface","page":"Primitives","title":"Cone/ConeSurface","text":"","category":"section"},{"location":"geometries/primitives/","page":"Primitives","title":"Primitives","text":"Cone\nConeSurface","category":"page"},{"location":"geometries/primitives/#Meshes.Cone","page":"Primitives","title":"Meshes.Cone","text":"Cone(base, apex)\n\nA cone with base disk and apex. See https://en.wikipedia.org/wiki/Cone.\n\nSee also ConeSurface.\n\n\n\n\n\n","category":"type"},{"location":"geometries/primitives/#Meshes.ConeSurface","page":"Primitives","title":"Meshes.ConeSurface","text":"ConeSurface(base, apex)\n\nA cone surface with base disk and apex. See https://en.wikipedia.org/wiki/Cone.\n\nSee also Cone.\n\n\n\n\n\n","category":"type"},{"location":"geometries/primitives/","page":"Primitives","title":"Primitives","text":"Cone(Disk(Plane((0,0,0), (0,0,1)), 1), (0,0,1)) |> viz","category":"page"},{"location":"geometries/primitives/#Frustum/FrustumSurface","page":"Primitives","title":"Frustum/FrustumSurface","text":"","category":"section"},{"location":"geometries/primitives/","page":"Primitives","title":"Primitives","text":"Frustum\nFrustumSurface","category":"page"},{"location":"geometries/primitives/#Meshes.Frustum","page":"Primitives","title":"Meshes.Frustum","text":"Frustum(bot, top)\n\nA frustum (truncated cone) with bot and top disks. See https://en.wikipedia.org/wiki/Frustum.\n\nSee also FrustumSurface.\n\n\n\n\n\n","category":"type"},{"location":"geometries/primitives/#Meshes.FrustumSurface","page":"Primitives","title":"Meshes.FrustumSurface","text":"FrustumSurface(bot, top)\n\nA frustum (truncated cone) surface with bot and top disks. See https://en.wikipedia.org/wiki/Frustum.\n\nSee also Frustum.\n\n\n\n\n\n","category":"type"},{"location":"geometries/primitives/","page":"Primitives","title":"Primitives","text":"Frustum(\n  Disk(Plane((0,0,0), (0,0,1)), 2),\n  Disk(Plane((0,0,10), (0,0,1)), 1)\n) |> viz","category":"page"},{"location":"geometries/primitives/#Torus","page":"Primitives","title":"Torus","text":"","category":"section"},{"location":"geometries/primitives/","page":"Primitives","title":"Primitives","text":"Torus","category":"page"},{"location":"geometries/primitives/#Meshes.Torus","page":"Primitives","title":"Meshes.Torus","text":"Torus(center, normal, major, minor)\n\nA torus centered at center with axis of revolution directed by  normal and with radii major and minor. \n\n\n\n\n\n","category":"type"},{"location":"geometries/primitives/","page":"Primitives","title":"Primitives","text":"Torus((0.,0.,0.), (1.,0.,0.), (0.,1.,0.), 0.2) |> viz","category":"page"},{"location":"geometries/primitives/#ParaboloidSurface","page":"Primitives","title":"ParaboloidSurface","text":"","category":"section"},{"location":"geometries/primitives/","page":"Primitives","title":"Primitives","text":"ParaboloidSurface","category":"page"},{"location":"geometries/primitives/#Meshes.ParaboloidSurface","page":"Primitives","title":"Meshes.ParaboloidSurface","text":"ParaboloidSurface(apex, radius, focallength)\n\nA paraboloid surface embedded in R³ and extending up to a distance radius from its focal axis, which is aligned along the z direction and passes through apex (the apex of the paraboloid). The equation of the paraboloid is the following:\n\nf(x y) = frac(x - x_0)^2 + (y - y_0)^24f + z_0qquadtextfor  x^2 + y^2  r^2\n\nwhere (x_0 y_0 z_0) is the apex of the parabola, f is the focal length, and r is the clip radius.\n\nParaboloidSurface(apex, radius)\n\nThis creates a paraboloid surface with focal length equal to 1.\n\nParaboloidSurface(apex)\n\nThis creates a paraboloid surface with focal length equal to 1 and a rim with unit radius.\n\nParaboloidSurface()\n\nSame as above, but here the apex is at Apex(0, 0, 0).\n\nSee also https://en.wikipedia.org/wiki/Paraboloid.\n\n\n\n\n\n","category":"type"},{"location":"geometries/primitives/","page":"Primitives","title":"Primitives","text":"ParaboloidSurface((5., 2., 4.), 1.0, 0.25) |> viz","category":"page"},{"location":"domains/meshes/#Meshes","page":"Meshes","title":"Meshes","text":"","category":"section"},{"location":"domains/meshes/","page":"Meshes","title":"Meshes","text":"using Meshes # hide\nimport CairoMakie as Mke # hide","category":"page"},{"location":"domains/meshes/","page":"Meshes","title":"Meshes","text":"Meshes can be constructed directly (e.g. CartesianGrid) or based on other constructs such as connectivity lists and topological structures (e.g. SimpleMesh).","category":"page"},{"location":"domains/meshes/#Overview","page":"Meshes","title":"Overview","text":"","category":"section"},{"location":"domains/meshes/","page":"Meshes","title":"Meshes","text":"Mesh\nGrid","category":"page"},{"location":"domains/meshes/#Meshes.Mesh","page":"Meshes","title":"Meshes.Mesh","text":"Mesh{M,CRS,TP}\n\nA mesh of geometries in a given manifold M with point coordinates specified in a coordinate reference system CRS. Unlike a general domain, a mesh has a well-defined topology TP.\n\n\n\n\n\n","category":"type"},{"location":"domains/meshes/#Meshes.Grid","page":"Meshes","title":"Meshes.Grid","text":"Grid{M,CRS,Dim}\n\nA grid of geometries in a given manifold M with points coordinates specified in a coordinate reference system CRS, which is embedded in Dim dimensions.\n\n\n\n\n\n","category":"type"},{"location":"domains/meshes/","page":"Meshes","title":"Meshes","text":"CartesianGrid","category":"page"},{"location":"domains/meshes/#Meshes.CartesianGrid","page":"Meshes","title":"Meshes.CartesianGrid","text":"CartesianGrid(dims, origin, spacing)\n\nA Cartesian grid with dimensions dims, lower left corner at origin and cell spacing spacing. The three arguments must have the same length.\n\nCartesianGrid(dims, origin, spacing, offset)\n\nA Cartesian grid with dimensions dims, with lower left corner of element offset at origin and cell spacing spacing.\n\nCartesianGrid(start, finish, dims=dims)\n\nAlternatively, construct a Cartesian grid from a start point (lower left) to a finish point (upper right).\n\nCartesianGrid(start, finish, spacing)\n\nAlternatively, construct a Cartesian grid from a start point to a finish point using a given spacing.\n\nCartesianGrid(dims)\nCartesianGrid(dim1, dim2, ...)\n\nFinally, a Cartesian grid can be constructed by only passing the dimensions dims as a tuple, or by passing each dimension dim1, dim2, ... separately. In this case, the origin and spacing default to (0,0,...) and (1,1,...).\n\nExamples\n\nCreate a 3D grid with 100x100x50 hexahedrons:\n\njulia> CartesianGrid(100, 100, 50)\n\nCreate a 2D grid with 100 x 100 quadrangles and origin at (10.0, 20.0):\n\njulia> CartesianGrid((100, 100), (10.0, 20.0), (1.0, 1.0))\n\nCreate a 1D grid from -1 to 1 with 100 segments:\n\njulia> CartesianGrid((-1.0,), (1.0,), dims=(100,))\n\n\n\n\n\n","category":"type"},{"location":"domains/meshes/","page":"Meshes","title":"Meshes","text":"# 3D Cartesian grid\ngrid = CartesianGrid(10, 10, 10)\n\nviz(grid, showsegments = true)","category":"page"},{"location":"domains/meshes/","page":"Meshes","title":"Meshes","text":"RectilinearGrid","category":"page"},{"location":"domains/meshes/#Meshes.RectilinearGrid","page":"Meshes","title":"Meshes.RectilinearGrid","text":"RectilinearGrid(x, y, z, ...)\nRectilinearGrid{Datum}(x, y, z, ...)\n\nA rectilinear grid with vertices at sorted coordinates x, y, z, ..., and a given Datum (default to NoDatum).\n\nExamples\n\nCreate a 2D rectilinear grid with regular spacing in x dimension and irregular spacing in y dimension:\n\njulia> x = 0.0:0.2:1.0\njulia> y = [0.0, 0.1, 0.3, 0.7, 0.9, 1.0]\njulia> RectilinearGrid(x, y)\n\n\n\n\n\n","category":"type"},{"location":"domains/meshes/","page":"Meshes","title":"Meshes","text":"# 2D rectilinear grid\nx = 0.0:0.2:1.0\ny = [0.0, 0.1, 0.3, 0.7, 0.9, 1.0]\ngrid = RectilinearGrid(x, y)\n\nviz(grid, showsegments = true)","category":"page"},{"location":"domains/meshes/","page":"Meshes","title":"Meshes","text":"StructuredGrid","category":"page"},{"location":"domains/meshes/#Meshes.StructuredGrid","page":"Meshes","title":"Meshes.StructuredGrid","text":"StructuredGrid(X, Y, Z, ...)\nStructuredGrid{Datum}(X, Y, Z, ...)\n\nA structured grid with vertices at sorted coordinates X, Y, Z, ..., and a given Datum (default to NoDatum).\n\nExamples\n\nCreate a 2D structured grid with regular spacing in x dimension and irregular spacing in y dimension:\n\njulia> X = repeat(0.0:0.2:1.0, 1, 6)\njulia> Y = repeat([0.0, 0.1, 0.3, 0.7, 0.9, 1.0]', 6, 1)\njulia> StructuredGrid(X, Y)\n\n\n\n\n\n","category":"type"},{"location":"domains/meshes/","page":"Meshes","title":"Meshes","text":"# 2D structured grid\nX = [i/20 * cos(3π/2 * (j-1) / (30-1)) for i in 1:20, j in 1:30]\nY = [i/20 * sin(3π/2 * (j-1) / (30-1)) for i in 1:20, j in 1:30]\ngrid = StructuredGrid(X, Y)\n\nviz(grid, showsegments = true)","category":"page"},{"location":"domains/meshes/","page":"Meshes","title":"Meshes","text":"SimpleMesh","category":"page"},{"location":"domains/meshes/#Meshes.SimpleMesh","page":"Meshes","title":"Meshes.SimpleMesh","text":"SimpleMesh(vertices, topology)\n\nA simple mesh with vertices and topology.\n\nSimpleMesh(vertices, connectivities; relations=false)\n\nAlternatively, construct a simple mesh with vertices and connectivities. The option relations can be used to build topological relations assuming that the connectivities represent the elements of the mesh.\n\nExamples\n\njulia> points = [(0.0, 0.0),(1.0, 0.0), (1.0, 1.0)]\njulia> connec = [connect((1,2,3))]\njulia> mesh   = SimpleMesh(points, connec)\n\nSee also Topology, GridTopology, HalfEdgeTopology, SimpleTopology.\n\nNotes\n\nThe option relations=true changes the underlying topology of the mesh to a HalfEdgeTopology instead of a SimpleTopology.\n\n\n\n\n\n","category":"type"},{"location":"domains/meshes/","page":"Meshes","title":"Meshes","text":"# global vector of 2D points\npoints = [(0,0),(1,0),(0,1),(1,1),(0.25,0.5),(0.75,0.5)]\n\n# connect the points into N-gon\nconnec = connect.([(1,2,6,5),(2,4,6),(4,3,5,6),(3,1,5)], Ngon)\n\n# 2D mesh made of N-gon elements\nmesh = SimpleMesh(points, connec)\n\nviz(mesh, showsegments = true)","category":"page"},{"location":"domains/meshes/#Connectivities","page":"Meshes","title":"Connectivities","text":"","category":"section"},{"location":"domains/meshes/","page":"Meshes","title":"Meshes","text":"Connectivity\nconnect\nmaterialize","category":"page"},{"location":"domains/meshes/#Meshes.Connectivity","page":"Meshes","title":"Meshes.Connectivity","text":"Connectivity{PL,N}\n\nA connectivity list of N indices representing a Polytope of type PL. Indices are taken from a global vector of Point.\n\nConnectivity objects are constructed with the connect function.\n\n\n\n\n\n","category":"type"},{"location":"domains/meshes/#Meshes.connect","page":"Meshes","title":"Meshes.connect","text":"connect(indices, [PL])\n\nConnect a list of indices from a global vector of Point into a Polytope of type PL.\n\nThe type PL can be a Ngon in which case the length of the indices is used to identify the actual polytope type.\n\nFinally, the type PL can be ommitted. In this case, the indices are assumed to be connected as a Ngon or as a Segment.\n\nExamples\n\nConnect indices into a Triangle:\n\nconnect((1,2,3), Triangle)\n\nConnect indices into N-gons, a Triangle and a Quadrangle:\n\nconnect.([(1,2,3), (2,3,4,5)], Ngon)\n\nConnect indices into N-gon or segment:\n\nconnect((1,2)) # Segment\nconnect((1,2,3)) # Triangle\nconnect((1,2,3,4)) # Quadrangle\n\n\n\n\n\n","category":"function"},{"location":"domains/meshes/#Meshes.materialize","page":"Meshes","title":"Meshes.materialize","text":"materialize(connec, points)\n\nMaterialize a face using the connec list and a global vector of points.\n\n\n\n\n\n","category":"function"},{"location":"domains/meshes/#Topology","page":"Meshes","title":"Topology","text":"","category":"section"},{"location":"domains/meshes/","page":"Meshes","title":"Meshes","text":"Topology\nGridTopology\nHalfEdgeTopology\nSimpleTopology","category":"page"},{"location":"domains/meshes/#Meshes.Topology","page":"Meshes","title":"Meshes.Topology","text":"Topology\n\nA data structure for constructing topological relations in a Mesh.\n\nReferences\n\nFloriani, L. & Hui, A. 2007. Shape representations based on simplicial and cell complexes\n\n\n\n\n\n","category":"type"},{"location":"domains/meshes/#Meshes.GridTopology","page":"Meshes","title":"Meshes.GridTopology","text":"GridTopology(dims, [periodic])\n\nA data structure for grid topologies with dims elements. Optionally, specify which dimensions are periodic. Default to aperiodic dimensions.\n\nExamples\n\njulia> GridTopology((10,20)) # 10x20 elements in a grid\njulia> GridTopology((10,20), (true,false)) # cylinder topology\n\n\n\n\n\n","category":"type"},{"location":"domains/meshes/#Meshes.HalfEdgeTopology","page":"Meshes","title":"Meshes.HalfEdgeTopology","text":"HalfEdgeTopology(elements; sort=true)\nHalfEdgeTopology(halfedges)\n\nA data structure for orientable 2-manifolds based on half-edges constructed from a vector of connectivity elements or from a vector of pairs of halfedges.\n\nThe option sort can be used to sort the elements in adjacent-first order in case of inconsistent orientation (i.e. mix of clockwise and counter-clockwise).\n\nExamples\n\nConstruct half-edge topology from a list of top-faces:\n\nelements = connect.([(1,2,3),(3,2,4,5)])\ntopology = HalfEdgeTopology(elements)\n\nSee also Topology.\n\nReferences\n\nKettner, L. (1999). Using generic programming for designing a data structure for polyhedral surfaces\n\nNotes\n\nTwo types of half-edges exist (Kettner 1999). This implementation is the most common type that splits the incident elements.\nA vector of halfedges together with a dictionary of half4elem and a dictionary of half4vert can be used to retrieve topolological relations in optimal time. In this case, half4vert[i] returns the index of the half-edge in halfedges with head equal to i. Similarly, half4elem[i] returns the index of a half-edge in halfedges that is in the element i. Additionally, a dictionary edge4pair returns the index of the edge (i.e. two halves) for a given pair of vertices.\nIf the elements of the mesh already have consistent orientation, then the sort option can be disabled for maximum performance.\n\n\n\n\n\n","category":"type"},{"location":"domains/meshes/#Meshes.SimpleTopology","page":"Meshes","title":"Meshes.SimpleTopology","text":"SimpleTopology(connectivities)\n\nA data structure that stores all connectivities of a mesh.\n\nNotes\n\nThis data structure is sometimes referred to as the \"soup of geometries\". It does not support topological relations and is therefore incompatible with algorithms that rely on neighborhood search. It is still useful for mesh visualization and IO operations.\n\n\n\n\n\n","category":"type"},{"location":"domains/meshes/#Relations","page":"Meshes","title":"Relations","text":"","category":"section"},{"location":"domains/meshes/","page":"Meshes","title":"Meshes","text":"TopologicalRelation\nBoundary\nCoboundary\nAdjacency","category":"page"},{"location":"domains/meshes/#Meshes.TopologicalRelation","page":"Meshes","title":"Meshes.TopologicalRelation","text":"TopologicalRelation\n\nA topological relation between faces of a Mesh implemented for a given Topology.\n\nAn object implementing this trait is a functor that can be evaluated at an integer index representing the face.\n\nExamples\n\n# create boundary relation mapping\n# 2-faces to 0-faces (i.e. vertices)\n∂ = Boundary{2,0}(topology)\n\n# list of vertices for first face\n∂(1)\n\nReferences\n\nFloriani, L. & Hui, A. 2007. Shape representations based on simplicial and cell complexes\n\n\n\n\n\n","category":"type"},{"location":"domains/meshes/#Meshes.Boundary","page":"Meshes","title":"Meshes.Boundary","text":"Boundary{P,Q}(topology)\n\nThe boundary relation from rank P to smaller rank Q for a given topology.\n\n\n\n\n\n","category":"type"},{"location":"domains/meshes/#Meshes.Coboundary","page":"Meshes","title":"Meshes.Coboundary","text":"Coboundary{P,Q}(topology)\n\nThe co-boundary relation from rank P to greater rank Q for a given topology.\n\n\n\n\n\n","category":"type"},{"location":"domains/meshes/#Meshes.Adjacency","page":"Meshes","title":"Meshes.Adjacency","text":"Adjacency{P}(topology)\n\nThe adjacency relation of rank P for a given topology.\n\n\n\n\n\n","category":"type"},{"location":"domains/meshes/","page":"Meshes","title":"Meshes","text":"Consider the following examples with the Boundary and Coboundary relations defined for the HalfEdgeTopology:","category":"page"},{"location":"domains/meshes/","page":"Meshes","title":"Meshes","text":"# global vector of 2D points\npoints = [(0,0),(1,0),(0,1),(1,1),(0.25,0.5),(0.75,0.5)]\n\n# connect the points into N-gon\nconnec = connect.([(1,2,6,5),(2,4,6),(4,3,5,6),(3,1,5)], Ngon)\n\n# 2D mesh made of N-gon elements\nmesh = SimpleMesh(points, connec)","category":"page"},{"location":"domains/meshes/","page":"Meshes","title":"Meshes","text":"# convert topology to half-edge topology\ntopo = convert(HalfEdgeTopology, topology(mesh))\n\n# boundary relation from faces (dim=2) to edges (dim=1)\n∂₂₁ = Boundary{2,1}(topo)\n\n# show boundary of first n-gon\n∂₂₁(1)","category":"page"},{"location":"domains/meshes/","page":"Meshes","title":"Meshes","text":"# co-boundary relation from edges (dim=1) to faces(dim=2)\n𝒞₁₂ = Coboundary{1,2}(topo)\n\n# show n-gons that share edge 3\n𝒞₁₂(3)","category":"page"},{"location":"domains/meshes/#Matrices","page":"Meshes","title":"Matrices","text":"","category":"section"},{"location":"domains/meshes/","page":"Meshes","title":"Meshes","text":"Based on topological relations, we can extract matrices that are widely used in applications such as laplacematrix, and adjacencymatrix.","category":"page"},{"location":"domains/meshes/#Laplace","page":"Meshes","title":"Laplace","text":"","category":"section"},{"location":"domains/meshes/","page":"Meshes","title":"Meshes","text":"laplacematrix","category":"page"},{"location":"domains/meshes/#Meshes.laplacematrix","page":"Meshes","title":"Meshes.laplacematrix","text":"laplacematrix(mesh; kind=nothing)\n\nThe Laplace-Beltrami (a.k.a. Laplacian) matrix of the mesh. Optionally, specify the kind of discretization.\n\nAvailable discretizations\n\n:uniform   - Lᵢⱼ = 1 / |𝒜(i)|, ∀j ∈ 𝒜(i)\n:cotangent - Lᵢⱼ = cot(αᵢⱼ) + cot(βᵢⱼ), ∀j ∈ 𝒜(i)\n\nwhere 𝒜(i) is the adjacency relation at vertex i.\n\nReferences\n\nBotsch et al. 2010. Polygon Mesh Processing.\nPinkall, U. & Polthier, K. 1993. Computing discrete minimal surfaces and their conjugates.\n\n\n\n\n\n","category":"function"},{"location":"domains/meshes/","page":"Meshes","title":"Meshes","text":"grid = CartesianGrid(10, 10)\n\nlaplacematrix(grid, kind = :uniform)","category":"page"},{"location":"domains/meshes/","page":"Meshes","title":"Meshes","text":"points = [(0, 0), (1, 0), (0, 1), (1, 1), (0.5, 0.5)]\nconnec = connect.([(1, 2, 5), (2, 4, 5), (4, 3, 5), (3, 1, 5)])\nmesh = SimpleMesh(points, connec)\n\nlaplacematrix(mesh, kind = :cotangent)","category":"page"},{"location":"domains/meshes/#Measure","page":"Meshes","title":"Measure","text":"","category":"section"},{"location":"domains/meshes/","page":"Meshes","title":"Meshes","text":"measurematrix","category":"page"},{"location":"domains/meshes/#Meshes.measurematrix","page":"Meshes","title":"Meshes.measurematrix","text":"measurematrix(mesh)\n\nThe measure (or \"mass\") matrix of the mesh, i.e. a diagonal matrix with entries Mᵢᵢ = 2Aᵢ where Aᵢ is (one-third of) the sum of the areas of triangles sharing vertex i.\n\nThe discrete cotangent Laplace-Beltrami operator can be written as Δ = M⁻¹L. When solving systems of the form Δu = f, it is useful to write Lu = Mf and exploit the symmetry of L.\n\n\n\n\n\n","category":"function"},{"location":"domains/meshes/","page":"Meshes","title":"Meshes","text":"grid = CartesianGrid(10, 10)\n\nmeasurematrix(grid)","category":"page"},{"location":"domains/meshes/","page":"Meshes","title":"Meshes","text":"points = [(0, 0), (1, 0), (0, 1), (1, 1), (0.5, 0.5)]\nconnec = connect.([(1, 2, 5), (2, 4, 5), (4, 3, 5), (3, 1, 5)])\nmesh = SimpleMesh(points, connec)\n\nmeasurematrix(mesh)","category":"page"},{"location":"domains/meshes/#Adjacency","page":"Meshes","title":"Adjacency","text":"","category":"section"},{"location":"domains/meshes/","page":"Meshes","title":"Meshes","text":"adjacencymatrix","category":"page"},{"location":"domains/meshes/#Meshes.adjacencymatrix","page":"Meshes","title":"Meshes.adjacencymatrix","text":"adjacencymatrix(mesh; rank=paramdim(mesh))\n\nThe adjacency matrix of the mesh using the adjacency relation of given rank for the underlying topology.\n\n\n\n\n\n","category":"function"},{"location":"domains/meshes/","page":"Meshes","title":"Meshes","text":"grid = CartesianGrid(10, 10)\n\nadjacencymatrix(grid)","category":"page"},{"location":"domains/meshes/","page":"Meshes","title":"Meshes","text":"adjacencymatrix(grid, rank = 0)","category":"page"},{"location":"predicates/#Predicates","page":"Predicates","title":"Predicates","text":"","category":"section"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"using Meshes # hide\nimport CairoMakie as Mke # hide","category":"page"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"This section lists predicates that can be used to check properties of geometric objects, both of themselves and relative to other geometric objects. ","category":"page"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"One important note to make is that these predicates are not necessarily exact. For example, rather than checking if a point p is exactly in a sphere of radius r centered at c, we check if norm(p-c) ≈ r with an absolute tolerance depending on the point type, so p might be slightly outside the sphere but still be considered as being inside. This absolute tolerance can be adjusted in specific scopes as discussed in the Tolerances section.","category":"page"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"Robust predicates are often expensive to apply and approximations typically suffice. If needed, consider ExactPredicates.jl or  AdaptivePredicates.jl.","category":"page"},{"location":"predicates/#isparametrized","page":"Predicates","title":"isparametrized","text":"","category":"section"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"isparametrized\nparamdim","category":"page"},{"location":"predicates/#Meshes.isparametrized","page":"Predicates","title":"Meshes.isparametrized","text":"isparametrized(object)\n\nTells whether or not the geometric object is parametrized, i.e. can be called as object(u₁, u₂, ..., uₙ) with local coordinates (u₁, u₂, ..., uₙ) ∈ [0,1]ⁿ where n is the parametric dimension.\n\nSee also paramdim.\n\n\n\n\n\n","category":"function"},{"location":"predicates/#Meshes.paramdim","page":"Predicates","title":"Meshes.paramdim","text":"paramdim(geometry)\n\nReturn the number of parametric dimensions of the geometry. For example, a sphere embedded in 3D has 2 parametric dimensions (polar and azimuthal angles).\n\nSee also isparametrized.\n\n\n\n\n\nparamdim(polytope)\n\nReturn the parametric dimension or rank of the polytope.\n\n\n\n\n\nparamdim(connectivity)\n\nReturn the parametric dimension of the connectivity.\n\n\n\n\n\nparamdim(domain)\n\nReturn the number of parametric dimensions of the domain as the number of parametric dimensions of its elements.\n\n\n\n\n\n","category":"function"},{"location":"predicates/#isperiodic","page":"Predicates","title":"isperiodic","text":"","category":"section"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"isperiodic","category":"page"},{"location":"predicates/#Meshes.isperiodic","page":"Predicates","title":"Meshes.isperiodic","text":"isperiodic(topology)\n\nTells whether or not the topology is periodic along each parametric dimension.\n\n\n\n\n\nisperiodic(geometry)\n\nTells whether or not the geometry is periodic along each parametric dimension.\n\n\n\n\n\nisperiodic(grid)\n\nTells whether or not the grid is periodic along each parametric dimension.\n\n\n\n\n\n","category":"function"},{"location":"predicates/#issimplex","page":"Predicates","title":"issimplex","text":"","category":"section"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"issimplex","category":"page"},{"location":"predicates/#Meshes.issimplex","page":"Predicates","title":"Meshes.issimplex","text":"issimplex(geometry)\n\nTells whether or not the geometry is a simplex.\n\n\n\n\n\nissimplex(connectivity)\n\nTells whether or not the connectivity is a simplex.\n\n\n\n\n\n","category":"function"},{"location":"predicates/#isclosed","page":"Predicates","title":"isclosed","text":"","category":"section"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"isclosed","category":"page"},{"location":"predicates/#Meshes.isclosed","page":"Predicates","title":"Meshes.isclosed","text":"isclosed(chain)\n\nTells whether or not the chain is closed.\n\nA closed chain is also known as a ring.\n\n\n\n\n\n","category":"function"},{"location":"predicates/#isconvex","page":"Predicates","title":"isconvex","text":"","category":"section"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"isconvex","category":"page"},{"location":"predicates/#Meshes.isconvex","page":"Predicates","title":"Meshes.isconvex","text":"isconvex(geometry)\n\nTells whether or not the geometry is convex.\n\n\n\n\n\n","category":"function"},{"location":"predicates/#issimple","page":"Predicates","title":"issimple","text":"","category":"section"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"issimple","category":"page"},{"location":"predicates/#Meshes.issimple","page":"Predicates","title":"Meshes.issimple","text":"issimple(polygon)\n\nTells whether or not the polygon is simple. See https://en.wikipedia.org/wiki/Simple_polygon.\n\n\n\n\n\nissimple(chain)\n\nTells whether or not the chain is simple.\n\nA chain is simple when all its segments only intersect at end points.\n\n\n\n\n\n","category":"function"},{"location":"predicates/#hasholes","page":"Predicates","title":"hasholes","text":"","category":"section"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"hasholes","category":"page"},{"location":"predicates/#Meshes.hasholes","page":"Predicates","title":"Meshes.hasholes","text":"hasholes(geometry)\n\nTells whether or not the geometry contains holes.\n\n\n\n\n\n","category":"function"},{"location":"predicates/#point-point","page":"Predicates","title":"point₁ ≤ point₂","text":"","category":"section"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"Base.:<(::Point, ::Point)\nBase.:>(::Point, ::Point)\nBase.:≤(::Point, ::Point)\nBase.:≥(::Point, ::Point)","category":"page"},{"location":"predicates/#Base.:<-Tuple{Point, Point}","page":"Predicates","title":"Base.:<","text":"<(A::Point, B::Point)\n\nThe lexicographical order of points A and B (<).\n\nA < B if the tuples of coordinates satisfy (a₁, a₂, ...) < (b₁, b₂, ...).\n\nSee https://en.wikipedia.org/wiki/Partially_ordered_set#Orders_on_the_Cartesian_product_of_partially_ordered_sets\n\n\n\n\n\n","category":"method"},{"location":"predicates/#Base.:>-Tuple{Point, Point}","page":"Predicates","title":"Base.:>","text":">(A::Point, B::Point)\n\nThe lexicographical order of points A and B (>).\n\nA > B if the tuples of coordinates satisfy (a₁, a₂, ...) > (b₁, b₂, ...).\n\nSee https://en.wikipedia.org/wiki/Partially_ordered_set#Orders_on_the_Cartesian_product_of_partially_ordered_sets\n\n\n\n\n\n","category":"method"},{"location":"predicates/#Base.:≤-Tuple{Point, Point}","page":"Predicates","title":"Base.:≤","text":"≤(A::Point, B::Point)\n\nThe lexicographical order of points A and B (\\le).\n\nA ≤ B if the tuples of coordinates satisfy (a₁, a₂, ...) ≤ (b₁, b₂, ...).\n\nSee https://en.wikipedia.org/wiki/Partially_ordered_set#Orders_on_the_Cartesian_product_of_partially_ordered_sets\n\n\n\n\n\n","category":"method"},{"location":"predicates/#Base.:≥-Tuple{Point, Point}","page":"Predicates","title":"Base.:≥","text":"≥(A::Point, B::Point)\n\nThe lexicographical order of points A and B (\\ge).\n\nA ≥ B if the tuples of coordinates satisfy (a₁, a₂, ...) ≥ (b₁, b₂, ...).\n\nSee https://en.wikipedia.org/wiki/Partially_ordered_set#Orders_on_the_Cartesian_product_of_partially_ordered_sets\n\n\n\n\n\n","category":"method"},{"location":"predicates/#point-point-2","page":"Predicates","title":"point₁ ⪯ point₂","text":"","category":"section"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"≺(::Point, ::Point)\n≻(::Point, ::Point)\n⪯(::Point, ::Point)\n⪰(::Point, ::Point)","category":"page"},{"location":"predicates/#Meshes.:≺-Tuple{Point, Point}","page":"Predicates","title":"Meshes.:≺","text":"≺(A::Point, B::Point)\n\nThe product order of points A and B (\\prec).\n\nA ≺ B if aᵢ < bᵢ for all coordinates aᵢ and bᵢ.\n\nSee https://en.wikipedia.org/wiki/Partially_ordered_set#Orders_on_the_Cartesian_product_of_partially_ordered_sets\n\n\n\n\n\n","category":"method"},{"location":"predicates/#Meshes.:≻-Tuple{Point, Point}","page":"Predicates","title":"Meshes.:≻","text":"≻(A::Point, B::Point)\n\nThe product order of points A and B (\\succ).\n\nA ≻ B if aᵢ > bᵢ for all coordinates aᵢ and bᵢ.\n\nSee https://en.wikipedia.org/wiki/Partially_ordered_set#Orders_on_the_Cartesian_product_of_partially_ordered_sets\n\n\n\n\n\n","category":"method"},{"location":"predicates/#Meshes.:⪯-Tuple{Point, Point}","page":"Predicates","title":"Meshes.:⪯","text":"⪯(A::Point, B::Point)\n\nThe product order of points A and B (\\preceq).\n\nA ⪯ B if aᵢ ≤ bᵢ for all coordinates aᵢ and bᵢ.\n\nSee https://en.wikipedia.org/wiki/Partially_ordered_set#Orders_on_the_Cartesian_product_of_partially_ordered_sets\n\n\n\n\n\n","category":"method"},{"location":"predicates/#Meshes.:⪰-Tuple{Point, Point}","page":"Predicates","title":"Meshes.:⪰","text":"⪰(A::Point, B::Point)\n\nThe product order of points A and B (\\succeq).\n\nA ⪰ B if aᵢ ≥ bᵢ for all coordinates aᵢ and bᵢ.\n\nSee https://en.wikipedia.org/wiki/Partially_ordered_set#Orders_on_the_Cartesian_product_of_partially_ordered_sets\n\n\n\n\n\n","category":"method"},{"location":"predicates/#point-geometry","page":"Predicates","title":"point ∈ geometry","text":"","category":"section"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"Base.in(::Point, ::Geometry)","category":"page"},{"location":"predicates/#Base.in-Tuple{Point, Geometry}","page":"Predicates","title":"Base.in","text":"point ∈ geometry\n\nTells whether or not the point is in the geometry.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#geometry-geometry","page":"Predicates","title":"geometry₁ ⊆ geometry₂","text":"","category":"section"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"Base.issubset(::Geometry, ::Geometry)","category":"page"},{"location":"predicates/#Base.issubset-Tuple{Geometry, Geometry}","page":"Predicates","title":"Base.issubset","text":"geometry₁ ⊆ geometry₂\n\nTells whether or not geometry₁ is contained in geometry₂.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#intersects","page":"Predicates","title":"intersects","text":"","category":"section"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"intersects\nsupportfun","category":"page"},{"location":"predicates/#Meshes.intersects","page":"Predicates","title":"Meshes.intersects","text":"intersects(geometry₁, geometry₂)\n\nTells whether or not geometry₁ and geometry₂ intersect.\n\nReferences\n\nGilbert, E., Johnson, D., Keerthi, S. 1988. A fast Procedure for Computing the Distance Between Complex Objects in Three-Dimensional Space\n\nNotes\n\nThe fallback algorithm works with any geometry that has a well-defined supportfun.\n\n\n\n\n\n","category":"function"},{"location":"predicates/#Meshes.supportfun","page":"Predicates","title":"Meshes.supportfun","text":"supportfun(geometry, direction)\n\nSupport function of geometry for given direction.\n\nReferences\n\nGilbert, E., Johnson, D., Keerthi, S. 1988. A fast Procedure for Computing the Distance Between Complex Objects in Three-Dimensional Space\n\n\n\n\n\n","category":"function"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"outer = [(0,0),(1,0),(1,1),(0,1)]\nhole1 = [(0.2,0.2),(0.4,0.2),(0.4,0.4),(0.2,0.4)]\nhole2 = [(0.6,0.2),(0.8,0.2),(0.8,0.4),(0.6,0.4)]\npoly  = PolyArea([outer, hole1, hole2])\nball1 = Ball((0.5,0.5), 0.05)\nball2 = Ball((0.3,0.3), 0.05)\nball3 = Ball((0.7,0.3), 0.05)\nball4 = Ball((0.3,0.3), 0.15)\n\nintersects(poly, ball1)","category":"page"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"intersects(poly, ball2)","category":"page"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"intersects(poly, ball3)","category":"page"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"intersects(poly, ball4)","category":"page"},{"location":"predicates/#iscollinear","page":"Predicates","title":"iscollinear","text":"","category":"section"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"iscollinear ","category":"page"},{"location":"predicates/#Meshes.iscollinear","page":"Predicates","title":"Meshes.iscollinear","text":"iscollinear(A, B, C)\n\nTells whether or not the points A, B and C are collinear.\n\n\n\n\n\n","category":"function"},{"location":"predicates/#iscoplanar","page":"Predicates","title":"iscoplanar","text":"","category":"section"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"iscoplanar ","category":"page"},{"location":"predicates/#Meshes.iscoplanar","page":"Predicates","title":"Meshes.iscoplanar","text":"iscoplanar(A, B, C, D)\n\nTells whether or not the points A, B, C and D are coplanar.\n\n\n\n\n\n","category":"function"},{"location":"vectors/#Vectors","page":"Vectors","title":"Vectors","text":"","category":"section"},{"location":"vectors/","page":"Vectors","title":"Vectors","text":"using Meshes # hide\nimport CairoMakie as Mke # hide","category":"page"},{"location":"vectors/","page":"Vectors","title":"Vectors","text":"Vec","category":"page"},{"location":"vectors/#Meshes.Vec","page":"Vectors","title":"Meshes.Vec","text":"Vec(x₁, x₂, ..., xₙ)\nVec((x₁, x₂, ..., xₙ))\n\nA geometric vector in Dim-dimensional space with coordinates in length units (default to meters) for linear algebra.\n\nBy default, integer coordinates are converted to float.\n\nA vector can be obtained by subtracting two Point objects.\n\nExamples\n\nA = Point(0.0, 0.0)\nB = Point(1.0, 0.0)\nv = B - A\n\n# 2D vectors\nVec(1.0, 2.0) # add default units\nVec(1.0m, 2.0m) # double precision as expected\nVec(1f0km, 2f0km) # single precision as expected\nVec(1m, 2m) # integer is converted to float by design\n\n# 3D vectors\nVec(1.0, 2.0, 3.0) # add default units\nVec(1.0m, 2.0m, 3.0m) # double precision as expected\nVec(1f0km, 2f0km, 3f0km) # single precision as expected\nVec(1m, 2m, 3m) # integer is converted to float by design\n\nNotes\n\nA Vec is a subtype of StaticVector from StaticArrays.jl\n\n\n\n\n\n","category":"type"},{"location":"algorithms/boundingbox/#Bounding-box","page":"Bounding box","title":"Bounding box","text":"","category":"section"},{"location":"algorithms/boundingbox/","page":"Bounding box","title":"Bounding box","text":"using Meshes # hide\nusing CoordRefSystems # hide\nimport CairoMakie as Mke # hide","category":"page"},{"location":"algorithms/boundingbox/","page":"Bounding box","title":"Bounding box","text":"boundingbox","category":"page"},{"location":"algorithms/boundingbox/#Meshes.boundingbox","page":"Bounding box","title":"Meshes.boundingbox","text":"boundingbox(object)\n\nAxis-aligned bounding box of object.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/boundingbox/","page":"Bounding box","title":"Bounding box","text":"pset = PointSet(rand(Point, 100, crs=Cartesian2D))\nbbox = boundingbox(pset)\n\nfig = Mke.Figure(size = (800, 400))\nviz(fig[1,1], bbox)\nviz!(fig[1,1], pset, color = :black)\nfig","category":"page"},{"location":"algorithms/boundingbox/","page":"Bounding box","title":"Bounding box","text":"box  = Box((-1, -1), (0, 0))\nball = Ball((0, 0), (1))\ngset = GeometrySet([box, ball])\nbbox = boundingbox(gset)\n\nfig = Mke.Figure(size = (800, 400))\nviz(fig[1,1], bbox)\nviz!(fig[1,1], boundary(box), color = :gray)\nviz!(fig[1,1], boundary(ball), color = :gray)\nfig","category":"page"},{"location":"algorithms/refinement/#Refinement","page":"Refinement","title":"Refinement","text":"","category":"section"},{"location":"algorithms/refinement/","page":"Refinement","title":"Refinement","text":"using Meshes # hide\nimport CairoMakie as Mke # hide","category":"page"},{"location":"algorithms/refinement/","page":"Refinement","title":"Refinement","text":"refine\nRefinementMethod","category":"page"},{"location":"algorithms/refinement/#Meshes.refine","page":"Refinement","title":"Meshes.refine","text":"refine(mesh, method)\n\nRefine mesh with refinement method.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/refinement/#Meshes.RefinementMethod","page":"Refinement","title":"Meshes.RefinementMethod","text":"RefinementMethod\n\nA method for refining meshes.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/refinement/#TriRefinement","page":"Refinement","title":"TriRefinement","text":"","category":"section"},{"location":"algorithms/refinement/","page":"Refinement","title":"Refinement","text":"TriRefinement","category":"page"},{"location":"algorithms/refinement/#Meshes.TriRefinement","page":"Refinement","title":"Meshes.TriRefinement","text":"TriRefinement()\n\nRefinement of polygonal meshes into triangles. A n-gon is subdivided into n triangles.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/refinement/","page":"Refinement","title":"Refinement","text":"grid = CartesianGrid(10, 10)\n\n# refine three times\nref1 = refine(grid, TriRefinement())\nref2 = refine(ref1, TriRefinement())\nref3 = refine(ref2, TriRefinement())\n\nfig = Mke.Figure(size = (800, 800))\nviz(fig[1,1], grid, showsegments = true)\nviz(fig[1,2], ref1, showsegments = true)\nviz(fig[2,1], ref2, showsegments = true)\nviz(fig[2,2], ref3, showsegments = true)\nfig","category":"page"},{"location":"algorithms/refinement/#QuadRefinement","page":"Refinement","title":"QuadRefinement","text":"","category":"section"},{"location":"algorithms/refinement/","page":"Refinement","title":"Refinement","text":"QuadRefinement","category":"page"},{"location":"algorithms/refinement/#Meshes.QuadRefinement","page":"Refinement","title":"Meshes.QuadRefinement","text":"QuadRefinement()\n\nRefinement of polygonal meshes into quadrangles. A n-gon is subdivided into n quadrangles.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/refinement/","page":"Refinement","title":"Refinement","text":"grid = CartesianGrid(10, 10)\n\n# refine three times\nref1 = refine(grid, QuadRefinement())\nref2 = refine(ref1, QuadRefinement())\nref3 = refine(ref2, QuadRefinement())\n\nfig = Mke.Figure(size = (800, 800))\nviz(fig[1,1], grid, showsegments = true)\nviz(fig[1,2], ref1, showsegments = true)\nviz(fig[2,1], ref2, showsegments = true)\nviz(fig[2,2], ref3, showsegments = true)\nfig","category":"page"},{"location":"algorithms/refinement/#RegularRefinement","page":"Refinement","title":"RegularRefinement","text":"","category":"section"},{"location":"algorithms/refinement/","page":"Refinement","title":"Refinement","text":"RegularRefinement","category":"page"},{"location":"algorithms/refinement/#Meshes.RegularRefinement","page":"Refinement","title":"Meshes.RegularRefinement","text":"RegularRefinement(f₁, f₂, ..., fₙ)\n\nRefine each dimension of the grid by given factors f₁, f₂, ..., fₙ.\n\nExamples\n\nrefine(grid2D, RegularRefinement(2, 3))\nrefine(grid3D, RegularRefinement(2, 3, 1))\n\n\n\n\n\n","category":"type"},{"location":"algorithms/refinement/","page":"Refinement","title":"Refinement","text":"grid = CartesianGrid(10, 10)\n\n# refine three times\nref1 = refine(grid, RegularRefinement(2, 2))\nref2 = refine(ref1, RegularRefinement(3, 2))\nref3 = refine(ref2, RegularRefinement(2, 3))\n\nfig = Mke.Figure(size = (800, 800))\nviz(fig[1,1], grid, showsegments = true)\nviz(fig[1,2], ref1, showsegments = true)\nviz(fig[2,1], ref2, showsegments = true)\nviz(fig[2,2], ref3, showsegments = true)\nfig","category":"page"},{"location":"algorithms/refinement/#Catmull-Clark","page":"Refinement","title":"Catmull-Clark","text":"","category":"section"},{"location":"algorithms/refinement/","page":"Refinement","title":"Refinement","text":"CatmullClark","category":"page"},{"location":"algorithms/refinement/#Meshes.CatmullClark","page":"Refinement","title":"Meshes.CatmullClark","text":"CatmullClark()\n\nCatmull-Clark refinement of polygonal meshes.\n\nStrictly speaking, the Catmull-Clark algorithm is used for subdivision surface modeling, not just mesh refinement. At each step of refinement, the vertices are adjusted to approximate a smooth surface.\n\nReferences\n\nCatmull & Clark. 1978. Recursively generated B-spline surfaces on arbitrary topological meshes\n\n\n\n\n\n","category":"type"},{"location":"algorithms/refinement/","page":"Refinement","title":"Refinement","text":"# define a cube in R^3\npoints = [(0,0,0),(1,0,0),(1,1,0),(0,1,0),(0,0,1),(1,0,1),(1,1,1),(0,1,1)]\nconnec = connect.([(1,4,3,2),(5,6,7,8),(1,2,6,5),(3,4,8,7),(1,5,8,4),(2,3,7,6)])\nmesh   = SimpleMesh(points, connec)\n\n# refine three times\nref1 = refine(mesh, CatmullClark())\nref2 = refine(ref1, CatmullClark())\nref3 = refine(ref2, CatmullClark())\n\nfig = Mke.Figure(size = (800, 800))\nviz(fig[1,1], mesh, showsegments = true)\nviz(fig[1,2], ref1, showsegments = true)\nviz(fig[2,1], ref2, showsegments = true)\nviz(fig[2,2], ref3, showsegments = true)\nfig","category":"page"},{"location":"algorithms/refinement/#TriSubdivision","page":"Refinement","title":"TriSubdivision","text":"","category":"section"},{"location":"algorithms/refinement/","page":"Refinement","title":"Refinement","text":"TriSubdivision","category":"page"},{"location":"algorithms/refinement/#Meshes.TriSubdivision","page":"Refinement","title":"Meshes.TriSubdivision","text":"TriSubdivision()\n\nRefinement of a mesh by preliminarly triangulating it if needed and then subdividing each triangle into four triangles.\n\nReferences\n\nCharles Loop. 1987. Smooth subdivision surfaces based on triangles. Master's thesis, University of Utah.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/refinement/","page":"Refinement","title":"Refinement","text":"grid = CartesianGrid(10, 10)\n\n# refine three times\nref1 = refine(grid, TriSubdivision())\nref2 = refine(ref1, TriSubdivision())\nref3 = refine(ref2, TriSubdivision())\n\nfig = Mke.Figure(size = (800, 800))\nviz(fig[1,1], grid, showsegments = true)\nviz(fig[1,2], ref1, showsegments = true)\nviz(fig[2,1], ref2, showsegments = true)\nviz(fig[2,2], ref3, showsegments = true)\nfig","category":"page"},{"location":"domains/sets/#Sets","page":"Sets","title":"Sets","text":"","category":"section"},{"location":"domains/sets/","page":"Sets","title":"Sets","text":"using Meshes # hide\nusing CoordRefSystems # hide\nimport CairoMakie as Mke # hide","category":"page"},{"location":"domains/sets/","page":"Sets","title":"Sets","text":"Geometry sets represent a collection of geometries without any connectivity information (a.k.a., \"soup of geometries\").","category":"page"},{"location":"domains/sets/","page":"Sets","title":"Sets","text":"GeometrySet","category":"page"},{"location":"domains/sets/#Meshes.GeometrySet","page":"Sets","title":"Meshes.GeometrySet","text":"GeometrySet(geometries)\n\nA set of geometries representing a Domain.\n\nExamples\n\nSet containing two balls centered at (0.0, 0.0) and (1.0, 1.0):\n\njulia> GeometrySet([Ball((0.0, 0.0)), Ball((1.0, 1.0))])\n\n\n\n\n\n","category":"type"},{"location":"domains/sets/","page":"Sets","title":"Sets","text":"GeometrySet(rand(Ball, 3)) |> viz","category":"page"},{"location":"domains/sets/","page":"Sets","title":"Sets","text":"PointSet","category":"page"},{"location":"domains/sets/#Meshes.PointSet","page":"Sets","title":"Meshes.PointSet","text":"PointSet(points)\n\nA set of points (a.k.a. point cloud) representing a Domain.\n\nExamples\n\nAll point sets below are the same and contain two points in R³:\n\njulia> PointSet([Point(1,2,3), Point(4,5,6)])\njulia> PointSet(Point(1,2,3), Point(4,5,6))\njulia> PointSet([(1,2,3), (4,5,6)])\njulia> PointSet((1,2,3), (4,5,6))\n\n\n\n\n\n","category":"type"},{"location":"domains/sets/","page":"Sets","title":"Sets","text":"PointSet(rand(Point, 100, crs=Cartesian2D)) |> viz","category":"page"},{"location":"#Meshes.jl","page":"Home","title":"Meshes.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Computational geometry and meshing algorithms in Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Build Status) (Image: Coverage Status) (Image: Stable Documentation) (Image: Latest Documentation) (Image: License File)","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Meshes.jl provides efficient implementations of concepts from computational geometry. It promotes rigorous mathematical definitions of spatial discretizations (a.k.a. meshes) that are adequate for describing general manifolds embedded in mathbbR^3, including surfaces described with spherical coordinates, and geometries described with multiple coordinate reference systems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Unlike other existing efforts in the Julia ecosystem, this project is being carefully designed to facilitate the use of meshes across different scientific domains. We follow a strict set of good software engineering practices, and are quite pedantic in our test suite to make sure that all our implementations are free of bugs in both single and double floating point precision. Additionally, we guarantee type stability.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The design of this project was motivated by various issues encountered with past attempts to represent geometry, which have been originally designed for visualization purposes (e.g. GeometryTypes.jl, GeometryBasics.jl) or specifically for finite element analysis (e.g. JuAFEM.jl, MeshCore.jl). We hope to provide a smoother experience with mesh representations that are adequate for finite finite element analysis, advanced geospatial modeling and visualization, not just one domain.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Geospatial Data Science with Julia book is a great resource to learn more about Meshes.jl and geospatial data (i.e. tables over meshes):","category":"page"},{"location":"","page":"Home","title":"Home","text":"<p align=\"center\">\n  <a href=\"https://juliaearth.github.io/geospatial-data-science-with-julia\">\n    <img src=\"https://juliaearth.github.io/geospatial-data-science-with-julia/images/cover.svg\" width=\"200px\" hspace=\"20\">\n  </a>\n</p>","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you have questions or would like to brainstorm ideas, don't hesitate to start a thread in our zulip channel.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Get the latest stable release with Julia's package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"] add Meshes","category":"page"},{"location":"#Quick-example","page":"Home","title":"Quick example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Although we didn't have time to document the functionality of the package properly, we still would like to illustrate some important features. For more information on available functionality, please consult the Reference guide and the suite of tests in the package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In all examples we assume the following packages are loaded:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Meshes\nimport CairoMakie as Mke","category":"page"},{"location":"#Points-and-vectors","page":"Home","title":"Points and vectors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Point is defined by its coordinates in a coordinate reference system from CoordRefSystems.jl. By default, a Cartesian coordinates with NoDatum are used.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Integer coordinates are converted to Float64 to fulfill the requirements of most geometric processing algorithms, which would be undefined in a discrete scale:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Point(0.0, 1.0) # double precision as expected","category":"page"},{"location":"","page":"Home","title":"Home","text":"Point(0f0, 1f0) # single precision as expected","category":"page"},{"location":"","page":"Home","title":"Home","text":"Point(0, 0) # Integer is converted to Float64 by design","category":"page"},{"location":"","page":"Home","title":"Home","text":"Point(1.0, 2.0, 3.0) # double precision as expected","category":"page"},{"location":"","page":"Home","title":"Home","text":"Point(1f0, 2f0, 3f0) # single precision as expected","category":"page"},{"location":"","page":"Home","title":"Home","text":"Point(1, 2, 3) # Integer is converted to Float64 by design","category":"page"},{"location":"","page":"Home","title":"Home","text":"Points can be subtracted to produce a vector:","category":"page"},{"location":"","page":"Home","title":"Home","text":"A = Point(1.0, 1.0)\nB = Point(3.0, 3.0)\nB - A","category":"page"},{"location":"","page":"Home","title":"Home","text":"They can't be added, but the vectors from the origin to the points can:","category":"page"},{"location":"","page":"Home","title":"Home","text":"to(A) + to(B)","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can add a point to a vector though, and get a new point:","category":"page"},{"location":"","page":"Home","title":"Home","text":"A + Vec(1, 1)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Every point and vector has well-defined coordinates:","category":"page"},{"location":"","page":"Home","title":"Home","text":"coords(A)","category":"page"},{"location":"#Primitives","page":"Home","title":"Primitives","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Primitive geometries such as Box, Ball, Sphere, Cylinder are those geometries that can be efficiently represented in a computer without discretization. We can construct such geometries using clean syntax:","category":"page"},{"location":"","page":"Home","title":"Home","text":"b = Box((0.0, 0.0, 0.0), (1.0, 1.0, 1.0))\n\nviz(b)","category":"page"},{"location":"","page":"Home","title":"Home","text":"s = Sphere((0.0, 0.0, 0.0), 1.0)\n\nviz(s)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The parameters of these primitive geometries can be queried easily:","category":"page"},{"location":"","page":"Home","title":"Home","text":"extrema(b)","category":"page"},{"location":"","page":"Home","title":"Home","text":"centroid(s), radius(s)","category":"page"},{"location":"","page":"Home","title":"Home","text":"As well as their measure (e.g. area, volume) and other geometric properties:","category":"page"},{"location":"","page":"Home","title":"Home","text":"measure(b)","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can sample random points on primitives using different methods:","category":"page"},{"location":"","page":"Home","title":"Home","text":"vs = sample(s, RegularSampling(10)) # 10 points over the sphere","category":"page"},{"location":"","page":"Home","title":"Home","text":"And collect the generator with:","category":"page"},{"location":"","page":"Home","title":"Home","text":"viz(collect(vs))","category":"page"},{"location":"#Polytopes","page":"Home","title":"Polytopes","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Polytopes are geometries with \"flat\" sides. They generalize polygons and polyhedra. Most commonly used polytopes are already defined in the project, including Segment, Ngon (e.g. Triangle, Quadrangle), Tetrahedron, Pyramid and Hexahedron.","category":"page"},{"location":"","page":"Home","title":"Home","text":"t = Triangle((0.0, 0.0), (1.0, 0.0), (0.0, 1.0))\n\nviz(t)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Some of these geometries have additional functionality like the measure (or area):","category":"page"},{"location":"","page":"Home","title":"Home","text":"measure(t)","category":"page"},{"location":"","page":"Home","title":"Home","text":"measure(t) == area(t)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Or the ability to know whether or not a point is inside:","category":"page"},{"location":"","page":"Home","title":"Home","text":"p = Point(0.5, 0.0)\n\np ∈ t","category":"page"},{"location":"","page":"Home","title":"Home","text":"For line segments, for example, we have robust intersection algorithms:","category":"page"},{"location":"","page":"Home","title":"Home","text":"s1 = Segment((0.0, 0.0), (1.0, 0.0))\ns2 = Segment((0.5, 0.0), (2.0, 0.0))\n\ns1 ∩ s2","category":"page"},{"location":"","page":"Home","title":"Home","text":"Polytopes are widely used in GIS software under names such as \"LineString\" and \"Polygon\". We provide robust implementations of these concepts, which are formally known as polygonal Chain and PolyArea.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can compute the orientation of a chain as clockwise or counter-clockwise, can open and close the chain, create bridges between the various inner rings with the outer ring, and other useful functionality:","category":"page"},{"location":"","page":"Home","title":"Home","text":"p = PolyArea((0,0), (2,0), (2,2), (1,3), (0,2))\n\nviz(p)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The orientation of the above polygonal area is counter-clockwise (CCW):","category":"page"},{"location":"","page":"Home","title":"Home","text":"orientation(p)","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can get the outer ring, and reverse it:","category":"page"},{"location":"","page":"Home","title":"Home","text":"r = rings(p) |> first\n\nreverse(r)","category":"page"},{"location":"","page":"Home","title":"Home","text":"A ring has circular vertices:","category":"page"},{"location":"","page":"Home","title":"Home","text":"v = vertices(r)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This means that we can index the vertices with indices that go beyond the range 1:nvertices(r). This is very useful for writing algorithms:","category":"page"},{"location":"","page":"Home","title":"Home","text":"v[1:10]","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can also compute angles of any given chain, no matter if it is open or closed:","category":"page"},{"location":"","page":"Home","title":"Home","text":"angles(r)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The sign of these angles is a function of the orientation:","category":"page"},{"location":"","page":"Home","title":"Home","text":"angles(reverse(r))","category":"page"},{"location":"","page":"Home","title":"Home","text":"In case of rings (i.e. closed chains), we can compute inner angles as well:","category":"page"},{"location":"","page":"Home","title":"Home","text":"innerangles(r)","category":"page"},{"location":"","page":"Home","title":"Home","text":"And there is a lot more functionality available like for instance determining whether or not a polygonal area or chain is simple:","category":"page"},{"location":"","page":"Home","title":"Home","text":"issimple(p)","category":"page"},{"location":"#Meshes","page":"Home","title":"Meshes","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Efficient (lazy) mesh representations are provided, including CartesianGrid and SimpleMesh, which are specific types of Domain:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Domain","category":"page"},{"location":"#Meshes.Domain","page":"Home","title":"Meshes.Domain","text":"Domain{M,CRS}\n\nA domain is an indexable collection of geometries (e.g. mesh) in a given manifold M with point coordinates specified in a coordinate reference system CRS.\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"grid = CartesianGrid(100, 100)\n\nviz(grid, showsegments = true)","category":"page"},{"location":"","page":"Home","title":"Home","text":"No memory is allocated:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@allocated CartesianGrid(10000, 10000, 10000)","category":"page"},{"location":"","page":"Home","title":"Home","text":"but we can still loop over the elements, which are quadrangles in 2D:","category":"page"},{"location":"","page":"Home","title":"Home","text":"collect(grid)","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can construct a general unstructured mesh with a global vector of points and a collection of Connectivity that store the indices to the global vector of points:","category":"page"},{"location":"","page":"Home","title":"Home","text":"points = [(0,0), (1,0), (0,1), (1,1), (0.25,0.5), (0.75,0.5)]\ntris  = connect.([(1,5,3), (4,6,2)], Triangle)\nquads = connect.([(1,2,6,5), (4,3,5,6)], Quadrangle)\nmesh = SimpleMesh(points, [tris; quads])","category":"page"},{"location":"","page":"Home","title":"Home","text":"viz(mesh, showsegments = true)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The actual geometries of the elements are materialized in a lazy fashion like with the Cartesian grid:","category":"page"},{"location":"","page":"Home","title":"Home","text":"collect(mesh)","category":"page"},{"location":"algorithms/orientation/#Orientation","page":"Orientation","title":"Orientation","text":"","category":"section"},{"location":"algorithms/orientation/","page":"Orientation","title":"Orientation","text":"using Meshes # hide\nimport CairoMakie as Mke # hide","category":"page"},{"location":"algorithms/orientation/","page":"Orientation","title":"Orientation","text":"Many geometric processing algorithms for 2D geometries rely on the concept of orientation, which is illustrated below.","category":"page"},{"location":"algorithms/orientation/","page":"Orientation","title":"Orientation","text":"OrientationType\norientation","category":"page"},{"location":"algorithms/orientation/#Meshes.OrientationType","page":"Orientation","title":"Meshes.OrientationType","text":"OrientationType\n\nThe different types of orientation of a ring. Possible values are CW and CCW.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/orientation/#Meshes.orientation","page":"Orientation","title":"Meshes.orientation","text":"orientation(geom)\n\nReturns the orientation of the geometry geom as either counter-clockwise (CCW) or clockwise (CW).\n\n\n\n\n\n","category":"function"},{"location":"algorithms/orientation/","page":"Orientation","title":"Orientation","text":"For polygons without holes, the function returns the orientation of the boundary, which is a Ring:","category":"page"},{"location":"algorithms/orientation/","page":"Orientation","title":"Orientation","text":"tri = Triangle((0, 0), (1, 0), (0, 1))\n\norientation(tri)","category":"page"},{"location":"algorithms/orientation/","page":"Orientation","title":"Orientation","text":"tri = Triangle((0, 0), (0, 1), (1, 0))\n\norientation(tri)","category":"page"},{"location":"algorithms/orientation/","page":"Orientation","title":"Orientation","text":"For polygons with holes, the function returns a vector with the orientation of all constituent rings:","category":"page"},{"location":"algorithms/orientation/","page":"Orientation","title":"Orientation","text":"outer = [(0, 0), (1, 0), (1, 1), (0, 1)]\nhole1 = [(0.2, 0.2), (0.2, 0.4), (0.4, 0.4), (0.4, 0.2)]\nhole2 = [(0.6, 0.2), (0.6, 0.4), (0.8, 0.4), (0.8, 0.2)]\npoly  = PolyArea([outer, hole1, hole2])\n\norientation(poly)","category":"page"},{"location":"algorithms/sampling/#Sampling","page":"Sampling","title":"Sampling","text":"","category":"section"},{"location":"algorithms/sampling/","page":"Sampling","title":"Sampling","text":"using Meshes # hide\nimport CairoMakie as Mke # hide","category":"page"},{"location":"algorithms/sampling/","page":"Sampling","title":"Sampling","text":"sample(::Any, ::SamplingMethod)\nSamplingMethod\nDiscreteSamplingMethod\nContinuousSamplingMethod","category":"page"},{"location":"algorithms/sampling/#StatsBase.sample-Tuple{Any, SamplingMethod}","page":"Sampling","title":"StatsBase.sample","text":"sample([rng], object, method)\n\nSample elements or points from geometric object with method. Optionally, specify random number generator rng.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/sampling/#Meshes.SamplingMethod","page":"Sampling","title":"Meshes.SamplingMethod","text":"SamplingMethod\n\nA method for sampling from geometric objects.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/sampling/#Meshes.DiscreteSamplingMethod","page":"Sampling","title":"Meshes.DiscreteSamplingMethod","text":"DiscreteSamplingMethod\n\nA method for sampling from discrete representations of geometric objects such as meshes or collections of geometries.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/sampling/#Meshes.ContinuousSamplingMethod","page":"Sampling","title":"Meshes.ContinuousSamplingMethod","text":"ContinuousSamplingMethod\n\nA method for sampling from continuous representations of geometric objects. In this case, geometric objects are interpreted as a set of points in the embedding space.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/sampling/#Discrete-sampling","page":"Sampling","title":"Discrete sampling","text":"","category":"section"},{"location":"algorithms/sampling/#UniformSampling","page":"Sampling","title":"UniformSampling","text":"","category":"section"},{"location":"algorithms/sampling/","page":"Sampling","title":"Sampling","text":"UniformSampling","category":"page"},{"location":"algorithms/sampling/#Meshes.UniformSampling","page":"Sampling","title":"Meshes.UniformSampling","text":"UniformSampling(size, replace=false, ordered=false)\n\nSample elements uniformly from a given domain/data. Produce a sample of given size with or without replacement depending on the replace option. The option ordered can be used to return samples in the same order of the domain/data.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/sampling/","page":"Sampling","title":"Sampling","text":"grid = CartesianGrid(20, 20)\n\n# uniform sampling without replacement\nsampler = UniformSampling(100, replace=false)\nblocks  = sample(grid, sampler)\n\nviz(blocks)","category":"page"},{"location":"algorithms/sampling/#WeightedSampling","page":"Sampling","title":"WeightedSampling","text":"","category":"section"},{"location":"algorithms/sampling/","page":"Sampling","title":"Sampling","text":"WeightedSampling","category":"page"},{"location":"algorithms/sampling/#Meshes.WeightedSampling","page":"Sampling","title":"Meshes.WeightedSampling","text":"WeightedSampling(size, [weights]; replace=false, ordered=false)\n\nSample elements from a given domain/data using weights. Produce a sample of given size with or without replacement depending on the replace option. The option ordered can be used to return samples in the same order of the original domain/data. By default weights are uniform.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/sampling/","page":"Sampling","title":"Sampling","text":"grid = CartesianGrid(20, 20)\n\n# upper blocks are 10x more likely\nweights = [fill(1, 200); fill(10, 200)]\n\n# weighted sampling without replacement\nsampler = WeightedSampling(100, weights, replace=false)\nblocks  = sample(grid, sampler)\n\nviz(blocks)","category":"page"},{"location":"algorithms/sampling/#BallSampling","page":"Sampling","title":"BallSampling","text":"","category":"section"},{"location":"algorithms/sampling/","page":"Sampling","title":"Sampling","text":"BallSampling","category":"page"},{"location":"algorithms/sampling/#Meshes.BallSampling","page":"Sampling","title":"Meshes.BallSampling","text":"BallSampling(radius; [options])\n\nA method for sampling isolated elements from a given domain/data according to a norm-ball of given radius.\n\nOptions\n\nmetric  - Metric for the ball (default to Euclidean())\nmaxsize - Maximum size of the resulting sample (default to none)\n\n\n\n\n\n","category":"type"},{"location":"algorithms/sampling/","page":"Sampling","title":"Sampling","text":"grid = CartesianGrid(20, 20)\n\n# sample blocks that are apart by a given radius\nsampler = BallSampling(5.0)\nblocks  = sample(grid, sampler)\n\nviz(blocks)","category":"page"},{"location":"algorithms/sampling/#Continuous-sampling","page":"Sampling","title":"Continuous sampling","text":"","category":"section"},{"location":"algorithms/sampling/#RegularSampling","page":"Sampling","title":"RegularSampling","text":"","category":"section"},{"location":"algorithms/sampling/","page":"Sampling","title":"Sampling","text":"RegularSampling","category":"page"},{"location":"algorithms/sampling/#Meshes.RegularSampling","page":"Sampling","title":"Meshes.RegularSampling","text":"RegularSampling(n1, n2, ..., np)\n\nGenerate samples regularly using n1 points along the first parametric dimension, n2 points along the second parametric dimension, ..., np points along the last parametric dimension.\n\nExamples\n\nSample sphere regularly with 360 longitudes and 180 latitudes:\n\nsample(Sphere((0,0,0), 1), RegularSampling(360, 180))\n\n\n\n\n\n","category":"type"},{"location":"algorithms/sampling/","page":"Sampling","title":"Sampling","text":"grid = CartesianGrid(20, 20)\n\n# sample points regularly\nsampler = RegularSampling(20, 30)\npoints  = sample(grid, sampler) |> collect\n\nviz(points)","category":"page"},{"location":"algorithms/sampling/#HomogeneousSampling","page":"Sampling","title":"HomogeneousSampling","text":"","category":"section"},{"location":"algorithms/sampling/","page":"Sampling","title":"Sampling","text":"HomogeneousSampling","category":"page"},{"location":"algorithms/sampling/#Meshes.HomogeneousSampling","page":"Sampling","title":"Meshes.HomogeneousSampling","text":"HomogeneousSampling(size, [weights])\n\nGenerate sample of given size from geometric object according to a homogeneous density. Optionally, provide weights to specify custom sampling weights for the elements of a domain.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/sampling/","page":"Sampling","title":"Sampling","text":"grid = CartesianGrid(20, 20)\n\n# sample points homogeneously\nsampler = HomogeneousSampling(100)\npoints  = sample(grid, sampler) |> collect\n\nviz(points)","category":"page"},{"location":"algorithms/sampling/#MinDistanceSampling","page":"Sampling","title":"MinDistanceSampling","text":"","category":"section"},{"location":"algorithms/sampling/","page":"Sampling","title":"Sampling","text":"MinDistanceSampling","category":"page"},{"location":"algorithms/sampling/#Meshes.MinDistanceSampling","page":"Sampling","title":"Meshes.MinDistanceSampling","text":"MinDistanceSampling(α, ρ=0.65, δ=100, metric=Euclidean())\n\nGenerate sample from geometric object such that all pairs of points are at least α units of distance away from each other. Optionally specify the relative radius ρ for the packing pattern, the oversampling factor δ and the metric.\n\nThis method is sometimes referred to as Poisson disk sampling or blue noise sampling in the computer graphics community.\n\nReferences\n\nLagae, A. & Dutré, P. 2007. A Comparison of Methods for Generating Poisson Disk Distributions\nBowers et al. 2010. Parallel Poisson disk sampling with spectrum analysis on surfaces\nMedeiros et al. 2014. Fast adaptive blue noise on polygonal surfaces\n\n\n\n\n\n","category":"type"},{"location":"algorithms/sampling/","page":"Sampling","title":"Sampling","text":"grid = CartesianGrid(20, 20)\n\n# sample points that are apart by a given radius\nsampler = MinDistanceSampling(3.0)\npoints  = sample(grid, sampler) |> collect\n\nviz(points)","category":"page"}]
}
